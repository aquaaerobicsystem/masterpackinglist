<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>üì¶ Packing List Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        :root {
            --bg: #f6f9ff;
            --ink: #202538;
            --brand: #0a5bd6;
            --card-shadow: 0 6px 16px rgba(25, 35, 58, .12);
            --card-shadow-hover: 0 10px 24px rgba(25, 35, 58, .18);
            --radius: 14px;
        }

        /* page */
        body {
            font-family: "Segoe UI", system-ui, Arial, sans-serif;
            background: var(--bg);
            color: var(--ink);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1300px;
            margin: 0 auto;
        }

        h1 {
            color: #0a3a8b;
            margin: 0 0 8px;
            letter-spacing: .2px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        h2 {
            color: #0a3a8b;
            margin: 16px 0 8px;
            display: flex; /* To align reset link */
            align-items: center; /* To align reset link */
            gap: 10px; /* Space between title and reset link */
            flex-wrap: wrap;
        }

        .total-jobs-count {
            font-size: 1.1rem;
            font-weight: 600;
            color: #50608a;
            background: #eef3ff;
            padding: 4px 10px;
            border-radius: 999px;
            margin-left: 8px;
            display: inline-block;
            vertical-align: middle;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0 22px;
            flex-wrap: wrap;
        }

        .search-wrap {
            position: relative;
            flex: 1 1 380px;
            max-width: 580px;
            min-width: 260px;
            display: flex;
            align-items: center;
        }

        #searchBar {
            width: 100%;
            padding: 10px 40px 10px 36px;
            border-radius: 10px;
            border: 1px solid #ccd6ee;
            font-size: 15px;
            outline: none;
            background: #fff;
            transition: box-shadow .2s, border-color .2s, transform .1s;
        }

        #searchBar:focus {
            border-color: #9fb6ff;
            box-shadow: 0 0 0 4px rgba(159, 182, 255, .25);
            transform: translateY(-1px);
        }

        .search-ico {
            position: absolute;
            left: 10px;
            width: 18px;
            height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .search-ico .mag {
            font-size: 15px;
            line-height: 1;
            opacity: .75;
            transition: opacity .15s;
        }

        .search-ico .spin {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(10, 58, 139, .25);
            border-top-color: #0a3a8b;
            animation: spin .8s linear infinite;
            display: none;
        }

        .search-wrap.searching .mag {
            opacity: 0;
        }

        .search-wrap.searching .spin {
            display: inline-block;
        }

        #clearSearch {
            position: absolute;
            right: 10px;
            display: none;
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 999px;
            background: #eef3ff;
            color: #2a3357;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            padding: 0;
            align-items: center;
            justify-content: center;
        }

        #clearSearch:hover {
            background: #e3ebff;
        }

        .search-wrap.has-value #clearSearch {
            display: inline-flex;
        }

        .btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(10, 59, 214, .10);
            background: #0a3a8b;
            color: #fff;
            font-weight: 700;
            letter-spacing: .2px;
            box-shadow: 0 6px 16px rgba(10, 58, 139, .18);
            cursor: pointer;
            transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease, filter .12s ease;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(10, 58, 139, .25);
        }

        .btn[disabled] {
            opacity: .55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            filter: saturate(.6);
        }

        .btn .ico {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, .45);
            border-top-color: #fff;
            animation: spin .9s linear infinite;
        }

        .btn .ico.paused {
            animation: none;
            border-top-color: #fff;
        }

        .btn[disabled]::after,
        .chip.is-disabled::after {
            content: "";
            position: absolute;
            top: -6px;
            left: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent 45%, #d33 45%, #d33 55%, transparent 55%), radial-gradient(circle 9px at 50% 50%, transparent 55%, #d33 56% 58%, transparent 59%);
            box-shadow: 0 0 0 2px #d33 inset, 0 1px 2px rgba(0, 0, 0, .2);
            pointer-events: none;
        }

        .next-refresh {
            font-size: 13px;
            color: #50608a;
            font-weight: 700;
            letter-spacing: .2px;
            padding: 8px 10px;
            background: #fff;
            border: 1px solid #e2e8f8;
            border-radius: 999px;
        }

        .footer-controls {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 10px;
            background: #fff;
            border: 1px solid #e2e8f8;
            border-radius: 999px;
        }

        .footer-controls label {
            margin: 0;
            font-size: 13px;
            color: #0a3a8b;
            font-weight: 700;
        }

        .footer-controls select {
            font-size: 13px;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid #ccd6ee;
            background: #fff;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 14px 0 20px;
        }

        .chip {
            position: relative;
            --bg: #fff;
            --fg: #1e2a3d;
            --ring: rgba(10, 91, 214, .28);
            display: grid;
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto auto;
            grid-template-areas: "icon label count" "icon pct count";
            align-items: center;
            gap: 2px 8px;
            padding: 10px 12px;
            border-radius: 999px;
            border: 1px solid rgba(16, 28, 61, .08);
            background: var(--bg);
            color: var(--fg);
            box-shadow: 0 4px 12px rgba(16, 28, 61, .08);
            cursor: pointer;
            transition: transform .14s ease, box-shadow .14s ease, outline-color .14s ease, background .14s ease, filter .14s ease, opacity .14s ease;
            outline: 2px solid transparent;
            user-select: none;
        }

        .chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 18px rgba(16, 28, 61, .14);
        }

        .chip:active {
            transform: translateY(0);
        }

        .chip.active {
            outline-color: var(--ring);
        }

        .chip .icon {
            grid-area: icon;
            font-size: 16px;
            filter: drop-shadow(0 1px 0 rgba(0, 0, 0, .08));
        }

        .chip .label {
            grid-area: label;
            font-weight: 700;
            font-size: 13.5px;
            letter-spacing: .2px;
        }

        .chip .count {
            grid-area: count;
            font-weight: 800;
            font-size: 13.5px;
            padding: 2px 8px;
            background: rgba(255, 255, 255, .6);
            border: 1px solid rgba(0, 0, 0, .06);
            border-radius: 999px;
        }

        .chip .pct {
            grid-area: pct;
            font-weight: 600;
            font-size: 12px;
            opacity: .85;
        }

        .chip.closed {
            --bg: linear-gradient(180deg, #5b50ff, #440ced);
            --fg: #fff;
        }

        .chip.nopackinglist {
            --bg: #ffffff;
        }

        .chip.critical {
            --bg: linear-gradient(180deg, #ff8f82, #f56565);
            --fg: #fff;
        }

        .chip.setshipdate {
            --bg: linear-gradient(180deg, #fff689, #ffe44d);
        }

        .chip.shipdateset {
            --bg: linear-gradient(180deg, #9bf3b1, #7be495);
        }

        .chip.shipfuture {
            --bg: linear-gradient(180deg, #cfe8ff, #a8d1ff);
        }

        .chip.missing {
            --bg: linear-gradient(180deg, #e3edf5, #cfd8dc);
        }

        .chip[disabled],
        .chip.is-disabled {
            opacity: .55;
            cursor: not-allowed !important;
            pointer-events: none;
            box-shadow: none;
            transform: none;
            filter: saturate(.6);
        }

        @media (max-width: 680px) {
            .legend {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 8px;
            }

            .chip {
                padding: 8px 10px;
            }

            .chip .label {
                font-size: 13px;
            }

            .chip .count {
                font-size: 12.5px;
            }

            .chip .pct {
                font-size: 11.5px;
            }
        }

        .table-results-count {
            color: #0a3a8b;
            font-weight: 700;
            margin: 20px 0 -5px 4px;
            display: none;
        }

        table,
        #kioskTable {
            width: 100%;
            border-collapse: collapse;
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--card-shadow);
            margin-top: 15px;
        }

        #mastersTableWrapper {
            max-height: 50vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            margin-top: 15px;
            overflow-x: hidden;
        }

        #mastersTable {
            margin-top: 0;
            box-shadow: none;
            border-radius: 0;
            overflow: visible;
        }

        th,
        td,
        #kioskTable th,
        #kioskTable td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #eef2fb;
            font-size: 12px; /* Font size 12px */
             /* Allow text wrap */
        }

        th,
        #kioskTable th {
            background: #0a3a8b;
            color: white;
            letter-spacing: .7px;
        }

        #mastersTable th {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        #missingJobsTableWrapper {
            max-height: 30vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            margin-top: 15px;
            overflow-x: hidden;
        }

        #missingJobsTableWrapper #missingJobsTable {
            margin-top: 0;
            box-shadow: none;
            border-radius: 0;
            overflow: visible;
        }

        #missingJobsTableWrapper #missingJobsTable th {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* --- Row Colors (Original High-Contrast) --- */
        tr.closed,
        #kioskTable tr.closed {
            background-color: #440ced !important;
            color: #fff;
        }

        tr.shipnotset,
        #kioskTable tr.shipnotset {
            background-color: #FFFF66 !important;
        }

        tr.shiptoday,
        #kioskTable tr.shiptoday {
            background-color: #90EE90 !important;
        }

        tr.shipfuture,
        #kioskTable tr.shipfuture {
            background-color: #ADD8E6 !important;
        }

        tr.nopackinglist,
        #kioskTable tr.nopackinglist {
            background-color: #FFFFFF !important;
        }

        /* Critical rule moved below others for higher specificity */
        tr.critical,
        #kioskTable tr.critical {
            background-color: LightCoral !important;
            color: #fff;
        }

        /* Tweak links inside tables */
        td a {
            color: var(--brand);
            text-decoration: none;
            font-weight: 600;
        }

        td a:hover {
            text-decoration: underline;
        }

        tr.closed td a {
            color: #c3ceff;
        }

        tr.critical td a {
            color: #fff;
            text-decoration: underline;
        }

        /* Ensure white links on critical */
        tr.shipnotset td a,
        tr.shiptoday td a,
        tr.shipfuture td a {
            color: #0035a0;
            font-weight: 700;
        }

        /* Urgency column styles */
        .urgency-overdue {
            font-weight: 700;
            color: #FF0000 !important;
        }

        /* Bright Red */
        .urgency-today {
            font-weight: 700;
            color: #000;
        }

        .urgency-future {
            color: #000;
        }

        .urgency-tbd {
            font-style: italic;
            opacity: 0.9;
            color: #000;
        }

        tr.closed .urgency-tbd {
            color: #fff;
        }

        tr.nopackinglist .urgency-tbd {
            color: #50608a;
        }

        /* Critical overrides Urgency text color */
        tr.critical .urgency-overdue,
        tr.critical .urgency-today,
        tr.critical .urgency-future,
        tr.critical .urgency-tbd {
            color: #fff !important;
            /* Ensure Urgency text is white on Critical rows */
        }

        /* Specific overrides for Missing table - FUTURE color */
        #missingJobsTable .urgency-future {
            color: #007a4d;
        }
        
        /* --- Sorting Styles --- */
        th.sortable {
            cursor: pointer;
            position: relative;
            -webkit-user-select: none;
            user-select: none;
            padding-right: 24px !important; /* Make space for arrows */
             /* Revert bottom padding */
        }
        th.sortable::before, th.sortable::after {
            position: absolute;
            right: 8px; /* Position to the right */
            opacity: 0.5;
            font-size: 0.8em;
            line-height: 1;
        }
        th.sortable::before {
            content: '‚ñ≤'; /* Original up arrow */
            bottom: 50%;
            transform: translateY(-1px); /* Adjust vertical alignment */
        }
        th.sortable::after {
            content: '‚ñº'; /* Original down arrow */
            top: 50%;
            transform: translateY(-1px); /* Adjust vertical alignment */
        }
        th.sortable:not(.sort-asc):not(.sort-desc)::before,
        th.sortable:not(.sort-asc):not(.sort-desc)::after {
            opacity: 0.2;
        }
        th.sortable.sort-asc::before { opacity: 1; }
        th.sortable.sort-asc::after { opacity: 0.2; }
        th.sortable.sort-desc::before { opacity: 0.2; }
        th.sortable.sort-desc::after { opacity: 1; }
        /* --- End Sorting Styles --- */

        /* --- Reset Sort Link --- */
        .reset-sort-link {
            font-size: 0.8em; /* Smaller font */
            font-weight: normal; /* Normal weight */
            margin-left: auto; /* Push to the right within the h2 flex container */
            color: var(--brand);
            text-decoration: none;
            vertical-align: middle; /* Align nicely with text */
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
            background-color: rgba(10, 91, 214, 0.1); /* Subtle background */
        }
        .reset-sort-link:hover {
            text-decoration: underline;
            background-color: rgba(10, 91, 214, 0.15);
        }
        /* --- End Reset Sort Link --- */


        .error {
            color: #c00;
            font-weight: 700;
            margin-top: 12px;
        }

        footer {
            margin: 40px 0 10px;
            text-align: center;
            font-size: 12px;
            color: #6c7590;
        }

        @media (prefers-reduced-motion:no-preference) {
            .pop {
                animation: pop .4s ease forwards;
                transform: translateY(6px) scale(.98);
                opacity: 0;
            }

            .pop:nth-child(1) {
                animation-delay: .04s
            }

            .pop:nth-child(2) {
                animation-delay: .08s
            }

            .pop:nth-child(3) {
                animation-delay: .12s
            }

            .pop:nth-child(4) {
                animation-delay: .16s
            }

            .pop:nth-child(5) {
                animation-delay: .20s
            }

            .pop:nth-child(6) {
                animation-delay: .24s
            }

            .pop:nth-child(7) {
                animation-delay: .28s
            }

            .fadeUp {
                animation: fadeUp .45s ease .2s forwards;
                opacity: 0;
                transform: translateY(8px);
            }

            @keyframes pop {
                to {
                    transform: none;
                    opacity: 1
                }
            }

            @keyframes fadeUp {
                to {
                    transform: none;
                    opacity: 1
                }
            }
        }

        .loader-overlay {
            position: fixed;
            inset: 0;
            background: linear-gradient(180deg, rgba(246, 249, 255, 0.98), rgba(235, 242, 255, 0.98));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity .35s ease, visibility .35s ease;
        }

        .loader-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
            color: #0a3a8b;
            text-align: center;
        }

        .loader .ring {
            width: 68px;
            height: 68px;
            border-radius: 50%;
            border: 6px solid rgba(10, 58, 139, .12);
            border-top-color: #7b61ff;
            border-right-color: #00e0ff;
            animation: spin 1s linear infinite;
            box-shadow: 0 8px 24px rgba(123, 97, 255, .25);
            background: radial-gradient(circle at 60% 40%, rgba(123, 97, 255, .15), transparent 40%);
        }

        .loader .msg {
            font-weight: 700;
            letter-spacing: .2px;
        }

        .loader .sub {
            font-size: 12.5px;
            color: #50608a;
        }

        .refresh-badge {
            position: fixed;
            top: 12px;
            right: 16px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            background: #0a3a8b;
            color: #fff;
            box-shadow: 0 8px 24px rgba(10, 58, 139, .25);
            font-size: 13px;
            letter-spacing: .2px;
            z-index: 10000;
            transform: translateY(0);
            opacity: 1;
            transition: transform .25s ease, opacity .25s ease, visibility .25s ease;
        }

        .refresh-badge.hidden {
            transform: translateY(-8px);
            opacity: 0;
            visibility: hidden;
        }

        .refresh-badge .spin {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, .35);
            border-top-color: #fff;
            animation: spin .8s linear infinite;
        }

        #legend.refreshing .chip {
            position: relative;
            overflow: hidden;
        }

        #legend.refreshing .chip::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(110deg, transparent 0%, rgba(255, 255, 255, .35) 12%, transparent 24%);
            background-size: 200% 100%;
            animation: shimmer 1.1s linear infinite;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        @keyframes shimmer {
            to {
                background-position: -200% 0;
            }
        }

        @keyframes rowIn {
            from {
                opacity: .2;
                transform: translateY(4px)
            }

            to {
                opacity: 1;
                transform: none
            }
        }

        @keyframes flash {
            0% {
                box-shadow: 0 0 0 0 rgba(123, 97, 255, .0);
            }

            30% {
                box-shadow: 0 0 0 6px rgba(123, 97, 255, .25);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(123, 97, 255, 0);
            }
        }

        tr.row-in {
            animation: rowIn .25s ease both;
        }

        tr.row-flash {
            animation: flash 1.0s ease-out 1;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .toast-wrap {
            position: fixed;
            top: 85px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20000;
            display: grid;
            gap: 10px;
            pointer-events: none;
            transition: top 0.3s ease, transform 0.3s ease;
        }

        @keyframes toastPop {
            0% {
                opacity: 0;
                transform: translateY(6px) scale(.94);
            }

            60% {
                opacity: 1;
                transform: translateY(-2px) scale(1.02);
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .toast {
            min-width: 340px;
            max-width: 560px;
            padding: 14px 16px;
            border-radius: 14px;
            background: linear-gradient(135deg, #0046cc, #0035a0);
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, .35);
            font-weight: 700;
            letter-spacing: .25px;
            box-shadow: 0 20px 50px rgba(0, 50, 120, .38), 0 4px 12px rgba(0, 0, 0, .18);
            border: 1px solid rgba(255, 255, 255, .25);
            opacity: 0;
            transform: translateY(6px) scale(.96);
            transition: opacity .18s ease, transform .18s ease;
            pointer-events: auto;
            backdrop-filter: blur(5px) saturate(1.4);
        }

        .toast.show {
            opacity: 1;
            animation: toastPop .28s ease-out forwards;
        }

        .toast.info {
            background: linear-gradient(135deg, #0057ff, #003bb3);
            box-shadow: 0 18px 40px rgba(0, 65, 200, .38), 0 2px 8px rgba(0, 40, 120, .22);
        }

        .toast.success {
            background: linear-gradient(135deg, #00b36b, #007a4d);
            box-shadow: 0 18px 40px rgba(0, 140, 90, .36), 0 2px 8px rgba(0, 80, 60, .22);
        }

        .toast.warn {
            background: linear-gradient(135deg, #ffb000, #d97a00);
            box-shadow: 0 18px 40px rgba(210, 120, 0, .38), 0 2px 8px rgba(100, 60, 0, .22);
        }

        .toast.error {
            background: linear-gradient(135deg, #e53935, #b71c1c);
            box-shadow: 0 18px 40px rgba(180, 30, 30, .38), 0 2px 8px rgba(80, 0, 0, .22);
        }

        #kiosk-wrapper {
            display: none;
        }

        .chart-container {
            display: none;
        }

        body.view-kiosk #kiosk-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        body.view-kiosk .chart-container {
            display: block;
            flex: 1 1 400px;
            max-width: 500px;
            min-width: 360px;
            margin: 0;
            background: #fff;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 20px;
            height: 450px;
            position: relative;
        }

        body.view-kiosk .chart-container canvas {
            max-height: 100%;
        }

        body.view-kiosk #kioskSection {
            display: block;
            flex: 2 1 500px;
        }

        #kioskSection {
            display: none;
        }

        #kioskSection h2 {
            color: #0a3a8b;
            margin: 0 0 8px;
        }

        body.view-kiosk #latestMastersTitle,
        body.view-kiosk #tableResultsCount,
        body.view-kiosk #mastersTableWrapper,
        body.view-kiosk #mastersTable,
        body.view-kiosk #missingJobsSection {
            display: none;
        }

        body.view-kiosk .toolbar,
        body.view-kiosk footer,
        body.view-kiosk #missingCard {
            display: none;
        }

        body.view-kiosk h1 {
            font-size: 2.5rem;
            justify-content: center;
            margin-bottom: 20px;
        }

        body.view-kiosk .total-jobs-count {
            display: none;
        }

        body.view-kiosk .legend {
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
        }

        body.view-kiosk .chip {
            padding: 14px 18px;
            border-radius: 14px;
        }

        body.view-kiosk .chip .label {
            font-size: 1rem;
        }

        body.view-kiosk .chip .count {
            font-size: 1rem;
            padding: 5px 12px;
        }

        body.view-kiosk .chip .pct {
            font-size: 0.85rem;
        }

        footer {
            text-align: center;
        }

        button.is-disabled,
        input.is-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="refreshBadge" class="refresh-badge hidden" aria-live="polite"><span class="spin"></span><strong>Updating‚Ä¶</strong></div>
    <div id="toastWrap" class="toast-wrap" aria-live="polite" aria-atomic="true"></div>
    <div id="loader" class="loader-overlay" aria-busy="true" aria-live="polite">
        <div class="loader">
            <div class="ring" role="progressbar" aria-label="Loading"></div>
            <div class="msg">Preparing your dashboard‚Ä¶</div>
            <div class="sub">Fetching active jobs, packing lists, critical status', and pending jobs</div>
        </div>
    </div>

    <div class="container">
        <h1>üì¶ Packing List Dashboard <span id="totalJobsCount" class="total-jobs-count" title="Total jobs loaded">(--)</span></h1>
        <div class="toolbar">
            <div id="searchWrap" class="search-wrap" role="search"><span class="search-ico" aria-hidden="true"><span class="mag">üîç</span><span class="spin" aria-hidden="true"></span></span><input id="searchBar" type="text" placeholder="Search by MasterID, Job #, SO, ProjectID, Project, etc‚Ä¶" aria-label="Search dashboard"><button id="clearSearch" type="button" aria-label="Clear search">√ó</button></div> <button id="refreshBtn" class="btn" title="Fetch the latest data"><span class="ico paused"></span>Refresh</button> <button id="restartBtn" class="btn" title="Restart (full reload of dashboard)"><span class="ico paused"></span>Restart</button> <span id="nextRefreshTimer" class="next-refresh" aria-live="polite" tabindex="-1">Next refresh in --:--</span>
            <div class="footer-controls"><label for="viewSelect">View Mode:</label><select id="viewSelect">
                    <option value="default">Default (All Data)</option>
                    <option value="kiosk">Kiosk Mode</option>
                </select></div>
        </div>
        <div class="legend" id="legend"> <button class="chip closed pop" data-filter="closed" title="Closed/Shipped"><span class="icon">‚úÖ</span><span class="label">Closed</span><span class="count" id="countClosed">--</span><span class="pct" id="pctClosed">--%</span></button> <button class="chip nopackinglist pop" data-filter="nopackinglist" title="No Packing List"><span class="icon">üìÑ</span><span class="label">No List</span><span class="count" id="countNoPackingList">--</span><span class="pct" id="pctNoPackingList">--%</span></button> <button class="chip critical pop" data-filter="critical" title="Jobs that are past ship date or missing required data"><span class="icon">üö®</span><span class="label">Critical</span><span class="count" id="countCritical">--</span><span class="pct" id="pctCritical">--%</span></button> <button class="chip setshipdate pop" data-filter="setshipdate" title="Set Ship Date"><span class="icon">‚è±Ô∏è</span><span class="label">Set Date</span><span class="count" id="countSetShipDate">--</span><span class="pct" id="pctSetShipDate">--%</span></button> <button class="chip shipdateset pop" data-filter="shipdateset" title="Ship Date Set (Today or Earlier)"><span class="icon">üì¶</span><span class="label">Date Set</span><span class="count" id="countShipDateSet">--</span><span class="pct"id="pctShipDateSet">--%</span></button> <button class="chip shipfuture pop" data-filter="shipfuture" title="Ship Date in Future"><span class="icon">üìÖ</span><span class="label">Future</span><span class="count" id="countShipFuture">--</span><span class="pct" id="pctShipFuture">--%</span></button> <button class="chip missing pop" id="missingCard" title="Jobs Not In MasterList"><span class="icon">‚ùî</span><span class="label">Not In MasterList</span><span class="count" id="countMissing">--</span></button> </div>
        <div id="kiosk-wrapper">
            <div class="chart-container fadeUp" style="background-color: #d3d3d37a;"><canvas id="statsChart"></canvas></div>
            <section id="kioskSection" class="fadeUp">
                <h2 id="kioskTableTitle">All Jobs (Sorted by Status & Ship Date)</h2>
                <table id="kioskTable">
                    <thead>
                        <tr>
                            <th>Job #</th>
                            <th>SO</th>
                            <th>Project ID</th>
                            <th>Packing List Name</th>
                            <th>Ship Date</th>
                            <th>Urgency</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </section>
        </div>
        <h3 id="tableResultsCount" class="table-results-count" aria-live="polite"></h3>
        <h2 class="fadeUp" id="latestMastersTitle">
            üßæ Latest Jobs (Sorted by Status & Ship Date)
            <a href="#" id="resetSortMasters" class="reset-sort-link" style="display: none;">Reset Sort</a>
        </h2>
        <div id="mastersTableWrapper" class="fadeUp">
            <table id="mastersTable">
                <thead>
                    <tr>
                        <th class="sortable" data-column="MasterID">ID</th>
                        <th class="sortable" data-column="JobNum">Job</th>
                        <th class="sortable" data-column="SO">SO</th>
                        <th class="sortable" data-column="ProjectID">ProjectID</th>
                        <th class="sortable" data-column="ProjectName">Project Name</th>
                        <th class="sortable" data-column="Name">PackingList</th>
                        <th class="sortable" data-column="ReqDate">ReqShip</th>
                        <th class="sortable" data-column="urgencySortKey">Urgency</th>
                        <th class="sortable" data-column="ShipDate">ShipDate</th>
                        <th class="sortable" data-column="UserCreated">CreatedBy</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <section id="missingJobsSection" class="fadeUp" aria-live="polite">
            <h2 id="missingJobsTitle" style="display:none;">
                 ‚ö†Ô∏è Jobs Not Added to MasterList
                 <a href="#" id="resetSortMissing" class="reset-sort-link" style="display: none;">Reset Sort</a>
            </h2>
            <h3 id="missingJobsResultsCount" class="table-results-count" aria-live="polite" style="display:none;"></h3>
            <div id="missingJobsTableWrapper" style="display:none;">
                <table id="missingJobsTable">
                    <thead>
                        <tr>
                            <th class="sortable" data-column="JobNum">Job #</th>
                            <th class="sortable" data-column="SO">SO</th>
                            <th class="sortable" data-column="ProjectID">Project ID</th>
                            <th class="sortable" data-column="ProjectName">Project Name</th>
                            <th class="sortable" data-column="ReqShipDate">Req Ship Date</th>
                            <th class="sortable" data-column="urgencySortKey">Urgency</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </section>
        <p id="error" class="error"></p>
        <footer><span>¬© Aqua-Aerobic Systems Inc | Protecting the World‚Äôs Water (v10.23.25.9.19)</span></footer>
    </div>

    <script>
        Chart.register(ChartDataLabels);

        let masters = [],
            missingJobs = [],
            activeFilter = null,
            missingVisible = false,
            criticalMap = new Map();
        let totalCriticalCount = 0;
        let myStatsChart = null;
        let missingPinned = false;
        let searchControlsMissing = false;
        // Default sort states
        const defaultMastersSort = { column: 'default_sort', direction: 'asc' };
        const defaultMissingSort = { column: 'JobNum', direction: 'asc' };
        let mastersSortState = { ...defaultMastersSort };
        let missingSortState = { ...defaultMissingSort };


        /**
         * Generic sorter for array of objects.
         * Handles numbers, strings (case-insensitive), and dates.
         */
        function sortData(array, column, direction = 'asc') {
            const asc = direction === 'asc';
            
            // Helper to parse dates robustly for sorting
            const parseDate = (val) => {
                if (!val) return null;
                const date = parseLocalDate(val); // Use existing robust parser
                return date ? date.getTime() : null;
            };

            return [...array].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                // Check for null/undefined
                if (valA == null && valB == null) return 0;
                if (valA == null) return asc ? -1 : 1; // Nulls/undefined first when ascending
                if (valB == null) return asc ? 1 : -1;

                let type = 'string';
                
                // Sniff type from first non-null value (or guess)
                if (typeof valA === 'number' && typeof valB === 'number') {
                    type = 'number';
                } else if (column.toLowerCase().includes('date') || column === 'ReqDate' || column === 'ShipDate') {
                        type = 'date';
                } else if (column === 'MasterID' || column === 'ProjectID' || column === 'urgencySortKey') { // <-- Removed 'JobNum'
                        type = 'number';
                        // Only sanitize if not urgencySortKey (which is already a number)
                        if (column !== 'urgencySortKey') { 
                            valA = Number(String(valA).replace(/[^0-9.-]+/g,"")) || 0;
                            valB = Number(String(valB).replace(/[^0-9.-]+/g,"")) || 0;
                        }
                }

                let compare = 0;
                switch (type) {
                    case 'number':
                        compare = valA - valB;
                        break;
                    case 'date':
                        const dateA = parseDate(valA);
                        const dateB = parseDate(valB);
                        if (dateA == null && dateB == null) compare = 0;
                        else if (dateA == null) compare = -1; // Null dates first
                        else if (dateB == null) compare = 1;
                        else compare = dateA - dateB;
                        break;
                    case 'string':
                    default:
                        // Special handling for ReqDate in masters table (strip date suffix before comparing)
                        if (column === 'ReqDate') {
                             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/;
                             valA = String(valA).replace(dateSuffixRegex, '');
                             valB = String(valB).replace(dateSuffixRegex, '');
                        }
                        compare = String(valA).toLowerCase().localeCompare(String(valB).toLowerCase());
                        break;
                }
                
                return asc ? compare : -compare;
            });
        }

        /**
         * Applies the correct sorter (default or user-selected) to a dataset.
         */
        function applySorters(data, tableType) {
            if (tableType === 'masters') {
                if (mastersSortState.column === 'default_sort') {
                    // Re-apply the default sort to the provided dataset
                    const sortedData = sortMastersDefault(data);
                    // The default sort is asc. If user clicked to get desc, reverse it.
                    return mastersSortState.direction === 'asc' ? sortedData : [...sortedData].reverse();
                } else {
                    // Apply the user-selected column sort
                    return sortData(data, mastersSortState.column, mastersSortState.direction);
                }
            } else if (tableType === 'missing') {
                 // Check if it's the default sort for missing table
                if (missingSortState.column === defaultMissingSort.column && missingSortState.direction === defaultMissingSort.direction) {
                     // Apply default sorting if needed (e.g., if default isn't simple column sort)
                     // For now, simple column sort is the default, so handle like others.
                     // If default was complex, add logic here like sortMastersDefault
                     return sortData(data, missingSortState.column, missingSortState.direction);
                } else {
                    // Apply the user-selected column sort
                    return sortData(data, missingSortState.column, missingSortState.direction);
                }
            }
            return data;
        }
        
        /**
         * Updates the sort-asc/sort-desc classes on table headers
         */
        function updateSortUI(tableId, state) {
            const table = document.getElementById(tableId);
            if (!table) return;
            table.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.column === state.column) {
                    th.classList.add(state.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function positionToast() {
            const toolbar = document.querySelector('.toolbar');
            const wrap = document.getElementById('toastWrap');
            if (!wrap || wrap.style.top === '15%') return;
            const top = (toolbar?.getBoundingClientRect().bottom || 72) + window.scrollY + 12;
            wrap.style.top = `${top}px`;
            wrap.style.left = '50%';
            wrap.style.transform = 'translateX(-50%)';
            const restartBtn = document.getElementById('refreshBtn');
            if (restartBtn) {
                const rect = restartBtn.getBoundingClientRect();
                wrap.style.left = `${rect.left + rect.width / 2}px`;
                wrap.style.top = `${rect.top - 12}px`;
                wrap.style.transform = 'translateX(-50%)';
            }
        }
        window.addEventListener('resize', positionToast);
        window.addEventListener('scroll', positionToast);
        requestAnimationFrame(positionToast);

        function showToast(message, {
            type = 'info',
            duration = 2600,
            silent = false,
            center = false
        } = {}) {
            if (silent) return;
            const wrap = document.getElementById('toastWrap');
            if (!wrap) return;
            if (center) {
                wrap.style.top = '15%';
                wrap.style.left = '50%';
                wrap.style.transform = 'translateX(-50%)';
            } else {
                wrap.style.transform = 'translateX(-50%)';
                const restartBtn = document.getElementById('refreshBtn');
                if (restartBtn) {
                    const rect = restartBtn.getBoundingClientRect();
                    wrap.style.left = `${rect.left + rect.width / 2}px`;
                    wrap.style.top = `${rect.top - 12 + window.scrollY}px`;
                } else {
                    const toolbar = document.querySelector('.toolbar');
                    const top = (toolbar?.getBoundingClientRect().bottom || 72) + window.scrollY + 12;
                    wrap.style.top = `${top}px`;
                    wrap.style.left = '50%';
                }
            }
            const currentlyDisabled = [];
            document.querySelectorAll('button:not(:disabled), input[type="text"]:not(:disabled)').forEach(el => {
                if (el.id === 'refreshBtn' || el.id === 'restartBtn') return;
                currentlyDisabled.push(el);
                el.disabled = true;
                el.classList.add('is-disabled');
            });
            const el = document.createElement('div');
            el.className = `toast ${type}`;
            el.textContent = message;
            wrap.appendChild(el);
            requestAnimationFrame(() => el.classList.add('show'));
            const remove = () => {
                el.classList.remove('show');
                setTimeout(() => {
                    if (el.parentNode) wrap.removeChild(el);
                    currentlyDisabled.forEach(el => {
                        el.disabled = false;
                        el.classList.remove('is-disabled');
                    });
                    if (!isRefreshing) {
                        [refreshBtn, restartBtn].forEach(b => {
                            if (b) {
                                b.disabled = false;
                                b.classList.remove('is-disabled');
                            }
                        });
                    }
                    if (center) {
                        wrap.style.top = '';
                        wrap.style.left = '50%';
                        wrap.style.transform = 'translateX(-50%)';
                        requestAnimationFrame(positionToast);
                    }
                }, 300);
            };
            setTimeout(remove, duration);
            return remove;
        }
        window.addEventListener('resize', () => {
            const wrap = document.getElementById('toastWrap');
            if (wrap && wrap.style.top !== '15%') {
                positionToast();
            }
        });
        window.addEventListener('scroll', () => {
            const wrap = document.getElementById('toastWrap');
            if (wrap && wrap.style.top !== '15%') {
                positionToast();
            }
        });
        
        function renderStatsChart() {
            const ctx = document.getElementById('statsChart');
            if (!ctx) return;
            const getCount = (id) => parseInt(document.getElementById(id)?.textContent, 10) || 0;
            const filterMap = ['closed', 'nopackinglist', 'critical', 'setshipdate', 'shipdateset', 'shipfuture'];
            const chartData = {
                labels: ['Closed', 'No List', 'Critical', 'Set Date', 'Date Set', 'Future'],
                datasets: [{
                    label: 'Job Count',
                    data: [getCount('countClosed'), getCount('countNoPackingList'), getCount('countCritical'), getCount('countSetShipDate'), getCount('countShipDateSet'), getCount('countShipFuture')],
                    backgroundColor: ['#440ced', '#FFFFFF', '#f56565', '#ffe44d', '#7be495', '#a8d1ff'],
                    borderColor: '#fff',
                    borderWidth: 2
                }]
            };
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'left',
                        align: 'center'
                    },
                    title: {
                        display: true,
                        text: 'Live Job Status Counts (Click Slice to Filter)',
                        font: {
                            size: 18,
                            weight: '600'
                        },
                        color: '#0a3a8b'
                    },
                    datalabels: {
                        formatter: (value) => value > 0 ? value : '',
                        color: '#fff',
                        font: {
                            weight: 'bold',
                            size: 16
                        },
                        textStrokeColor: 'rgba(0,0,0,0.6)',
                        textStrokeWidth: 2,
                        textShadowColor: 'rgba(0,0,0,0.6)',
                        textShadowBlur: 3
                    }
                },
                onClick: (event, elements) => {
                    if (elements.length > 0) {
                        const index = elements[0].index;
                        const filterValue = filterMap[index];
                        if (filterValue) {
                            const legendButton = document.querySelector(`.chip[data-filter="${filterValue}"]`);
                            if (legendButton) legendButton.click();
                            else console.warn(`Could not find legend button for filter: ${filterValue}`);
                        }
                    }
                }
            };
            if (myStatsChart) {
                if (myStatsChart.config.type !== 'pie') {
                    myStatsChart.destroy();
                    myStatsChart = null;
                } else {
                    myStatsChart.data = chartData;
                    myStatsChart.options = chartOptions;
                    myStatsChart.update();
                    return;
                }
            }
            myStatsChart = new Chart(ctx, {
                type: 'pie',
                data: chartData,
                options: chartOptions
            });
        }

        let fetchController = null;
        let renderSession = 0;

        function beginSession() {
            if (fetchController) try {
                fetchController.abort();
            } catch {}
            fetchController = new AbortController();
            renderSession++;
            return {
                id: renderSession,
                signal: fetchController.signal
            };
        }

        function isCurrentSession(id) {
            return id === renderSession;
        }
        const criticalByJob = new Map();

        const classForFilter = {
            closed: "closed",
            nopackinglist: "nopackinglist",
            critical: "critical",
            setshipdate: "shipnotset",
            shipdateset: "shiptoday",
            shipfuture: "shipfuture"
        };
        const loaderEl = document.getElementById('loader');

        function showLoader() {
            loaderEl.classList.remove('hidden');
            loaderEl.setAttribute('aria-busy', 'true');
        }

        function hideLoader() {
            loaderEl.classList.add('hidden');
            loaderEl.setAttribute('aria-busy', 'false');
        }
        const refreshIntervalMs = 300000;
        let autoTimer = null,
            isRefreshing = false;
        let prevMastersSig = "",
            prevMissingSig = "";
        let nextRefreshAt = 0;
        let countdownTimer = null;
        const refreshBadge = document.getElementById('refreshBadge');
        const refreshBtn = document.getElementById('refreshBtn');
        const restartBtn = document.getElementById('restartBtn');
        const countdownEl = document.getElementById('nextRefreshTimer');
        const searchWrap = document.getElementById('searchWrap');
        const searchInput = document.getElementById('searchBar');
        const clearBtn = document.getElementById('clearSearch');
        let lastViewKeys = new Set();
        let listenersReady = false;
        let searchDebounce = null;

        function setLegendDisabled(disabled) {
            document.querySelectorAll('#legend .chip, #missingCard').forEach(btn => {
                if (disabled) {
                    btn.setAttribute('disabled', 'disabled');
                    btn.setAttribute('aria-disabled', 'true');
                    if (!btn.hasAttribute('data-prev-tabindex')) btn.setAttribute('data-prev-tabindex', btn.tabIndex);
                    btn.tabIndex = -1;
                    btn.classList.add('is-disabled');
                } else {
                    btn.removeAttribute('disabled');
                    btn.removeAttribute('aria-disabled');
                    const prev = btn.getAttribute('data-prev-tabindex');
                    btn.tabIndex = prev !== null ? Number(prev) : 0;
                    btn.removeAttribute('data-prev-tabindex');
                    btn.classList.remove('is-disabled');
                }
            });
        }

        function setRefreshing(on) {
            const legend = document.getElementById('legend');
            if (on) {
                refreshBadge.classList.remove('hidden');
                legend.classList.add('refreshing');
                setLegendDisabled(true);
                [refreshBtn, restartBtn].forEach(b => b.setAttribute('disabled', 'disabled'));
                [refreshBtn, restartBtn].forEach(b => b.querySelector('.ico')?.classList.remove('paused'));
                searchWrap?.classList.add('searching');
            } else {
                refreshBadge.classList.add('hidden');
                legend.classList.remove('refreshing');
                setLegendDisabled(false);
                [refreshBtn, restartBtn].forEach(b => b.removeAttribute('disabled'));
                [refreshBtn, restartBtn].forEach(b => b.querySelector('.ico')?.classList.add('paused'));
                setTimeout(() => {
                    if (refreshBtn) {
                        refreshBtn.disabled = false;
                        refreshBtn.classList.remove('is-disabled');
                    }
                    if (restartBtn) {
                        restartBtn.disabled = false;
                        restartBtn.classList.remove('is-disabled');
                    }
                }, 600);
            }
        }

        function animateRows(newKeys = null) {
            const trs = document.querySelectorAll('#mastersTable tbody tr');
            trs.forEach(tr => {
                tr.classList.add('row-in');
                setTimeout(() => tr.classList.remove('row-in'), 300);
                if (newKeys) {
                    const job = tr.children[1]?.textContent.trim();
                    const name = tr.children[5]?.textContent.trim() || "";
                    const key = `${job}|${name}`;
                    if (newKeys.has(key) && !lastViewKeys.has(key)) {
                        tr.classList.add('row-flash');
                        setTimeout(() => tr.classList.remove('row-flash'), 1000);
                    }
                }
            });
        }

        function computeMastersSignature(list) {
            const dataToSign = typeof rawMasters !== 'undefined' ? rawMasters : list;
            return dataToSign.map(r => `${r.MasterID}|${r.JobNum}|${r.Name}|${r.ShipDate}|${r.JobClosed}|${r.HasShipDate}|${r.ReqDate}`).join('¬ß');
        }

        function computeMissingSignature(list) {
            return list.map(r => `${r.JobNum}|${r.SO}|${r.ProjectID}|${r.ProjectName}|${r.ReqShipDate}`).join('¬ß');
        }

        function formatShortDate(value) {
            if (!value) return "";
            const s = String(value);
            if (s.startsWith('1900-01-01')) return "";
            const justDate = s.split("T")[0];
            if (/^\d{4}-\d{2}-\d{2}$/.test(justDate)) {
                const [y, m, d] = justDate.split("-");
                return `${m}/${d}/${y}`;
            }
            const dt = new Date(s);
            if (isNaN(dt)) return s;
            return dt.toLocaleDateString(undefined, {
                year: "numeric",
                month: "2-digit",
                day: "2-digit"
            });
        }

        function setPct(id, n, d) {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = d ? `${Math.round((n/d)*100)}%` : "0%";
        }

        /**
         * Helper function to parse a "YYYY-MM-DD" string as a local date at midnight.
         */
        function parseLocalDate(dateStr) {
            if (!dateStr || typeof dateStr !== 'string') return null;
            const parts = dateStr.split('T')[0].split('-'); // Get just the date part and split
            if (parts.length === 3) {
                // new Date(year, monthIndex, day)
                const date = new Date(parts[0], parts[1] - 1, parts[2]);
                if (!isNaN(date.getTime())) {
                    date.setHours(0, 0, 0, 0);
                    return date;
                }
            }
            return null; // Return null for invalid or unparseable dates
        }

        // Urgency logic
        function getUrgency(reqDateStr, shipDateStr, jobClosed) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const ONE_DAY_MS = 1000 * 60 * 60 * 24;

            if (jobClosed) {
                return {
                    text: "Closed",
                    class: "urgency-tbd",
                    sortKey: 1000000 // Last
                };
            }

            // --- Overdue Check 1 (Req Date - handle potential suffix) ---
            let reqDateForCalc = reqDateStr;
             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/;
             if(typeof reqDateStr === 'string' && dateSuffixRegex.test(reqDateStr)) {
                 // Attempt to parse the date part if it exists
                 const match = reqDateStr.match(dateSuffixRegex);
                 reqDateForCalc = match ? match[1] : null; // Use the captured date part or null
             }

            if (reqDateForCalc) {
                const reqShipDate = parseLocalDate(reqDateForCalc);
                if (reqShipDate && reqShipDate < today) {
                    const diffTime = today.getTime() - reqShipDate.getTime();
                    const pastDays = Math.round(diffTime / ONE_DAY_MS);
                    const displayDays = pastDays > 0 ? pastDays : 1;
                    return {
                        text: `Overdue ${displayDays} day${displayDays > 1 ? 's' : ''}`,
                        class: "urgency-overdue",
                        sortKey: -displayDays // First (negative)
                    };
                }
            }


            // --- Ship Date Check (Overdue or Due In) ---
            if (shipDateStr && shipDateStr !== "ShipDate Not Set") {
                const shipDate = parseLocalDate(shipDateStr);
                if (shipDate) {
                    const diffTime = shipDate.getTime() - today.getTime();
                    const diffDays = Math.round(diffTime / ONE_DAY_MS);

                    if (diffDays < 0) { // Overdue
                        const pastDaysActual = Math.abs(diffDays);
                        const displayDaysActual = pastDaysActual > 0 ? pastDaysActual : 1;
                        return {
                            text: `Overdue ${displayDaysActual} day${displayDaysActual > 1 ? 's' : ''}`,
                            class: "urgency-overdue",
                            sortKey: -displayDaysActual // First (negative)
                        };
                    } else { // Not Overdue (Today or Future)
                        return {
                            text: `Due in ${diffDays} day${diffDays === 1 ? '' : 's'}`,
                            class: (diffDays === 0) ? "urgency-today" : "urgency-future",
                            sortKey: diffDays // Second (positive)
                        };
                    }
                }
            }

            // --- Fallback: Check Req Date for *future* date (using potentially stripped date) ---
            if (reqDateForCalc) {
                 const reqShipDate = parseLocalDate(reqDateForCalc);
                 if (reqShipDate && reqShipDate >= today) { // It's today or in the future
                     const diffTime = reqShipDate.getTime() - today.getTime();
                     const diffDays = Math.round(diffTime / ONE_DAY_MS);
                     return {
                         text: `Due in ${diffDays} day${diffDays === 1 ? '' : 's'}`,
                         class: (diffDays === 0) ? "urgency-today" : "urgency-future",
                         sortKey: diffDays // Second (positive)
                     };
                 }
            }

            // Truly no date info
            return {
                text: "TBD",
                class: "urgency-tbd",
                sortKey: 999999 // Third
            };
        }

        function getUrgencySimple(reqShipDateStr) {
            if (!reqShipDateStr) return {
                text: "--",
                class: "",
                sortKey: 999999 // TBD
            };

            const reqShipDate = parseLocalDate(reqShipDateStr);
            if (!reqShipDate) return {
                text: "--",
                class: "",
                sortKey: 999999 // TBD
            };

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (reqShipDate < today) {
                const diffTime = today.getTime() - reqShipDate.getTime();
                const pastDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                const displayDays = pastDays > 0 ? pastDays : 1;
                return {
                    text: `Overdue ${displayDays} day${displayDays > 1 ? 's' : ''}`,
                    class: "urgency-overdue",
                    sortKey: -displayDays // First (negative)
                };
            } else {
                const diffTime = reqShipDate.getTime() - today.getTime();
                const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                return {
                    text: `Due in ${diffDays} day${diffDays === 1 ? '' : 's'}`,
                    class: (diffDays === 0) ? "urgency-today" : "urgency-future",
                    sortKey: diffDays // Second (positive)
                };
            }
        }

        // Sorting helper
        function getSortGroup(row) {
            const nameVal = (row.Name || "").trim();
            const shipDateStr = (row.ShipDate || "").trim();
            if (row.JobClosed) return 3;
            if (nameVal === "Packing List Not Set") return 2;
            if (shipDateStr === "ShipDate Not Set") return 1;
            return 0;
        };
        function parseDateForSort(s) {
            const d = Date.parse(s);
            return isNaN(d) ? Infinity : d;
        };

        function sortMastersDefault(mastersArray) {
            return [...mastersArray].sort((a, b) => {
                const groupA = getSortGroup(a);
                const groupB = getSortGroup(b);
                if (groupA !== groupB) return groupA - groupB;
                if (groupA === 0) return parseDateForSort(a.ShipDate) - parseDateForSort(b.ShipDate);
                return 0;
            });
        }

        // Countdown handling
        function updateCountdown() {
            if (!nextRefreshAt) {
                countdownEl.textContent = "Next refresh in --:--";
                return;
            }
            const ms = Math.max(0, nextRefreshAt - Date.now());
            const sec = Math.floor(ms / 1000);
            const m = String(Math.floor(sec / 60)).padStart(2, '0');
            const s = String(sec % 60).padStart(2, '0');
            countdownEl.textContent = `Next refresh in ${m}:${s}`;
        }

        function startCountdown() {
            if (countdownTimer) clearInterval(countdownTimer);
            updateCountdown();
            countdownTimer = setInterval(updateCountdown, 1000);
        }

        // SSRS link helpers
        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function escapeHtml(s) {
            return String(s ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function getJobsForSO(so) {
            const key = (so ?? "").toString();
            const jobs = (Array.isArray(masters) ? masters : []).filter(r => (r.SO ?? "").toString() === key).map(r => r.JobNum).filter(Boolean);
            return [...new Set(jobs)];
        }

        function buildSsrsUrl(row) {
            const nameVal = (row.Name || "").trim();
            if (nameVal === "Packing List Not Set") return null;
            const so = row.SO ?? "";
            if (!so) return null;
            const masterId = row.MasterID ?? "";
            const psRaw = (row.PS ?? "").toString().trim();
            const shipRaw = (row.ShipDate ?? "").toString().trim();
            const gPS = psRaw ? psRaw : "N/A";
            const gDate = (shipRaw && shipRaw !== "ShipDate Not Set") ? shipRaw : "TBD";
            const jobs = getJobsForSO(so);
            const list = jobs.length ? jobs : [row.JobNum].filter(Boolean);
            const jobParams = list.map(j => `&JobNum=${encodeURIComponent(j)}`).join("");
            const base = "http://aquaerprep/ReportServer/Pages/ReportViewer.aspx";
            const path = "%2fEpicor10Live%2freports%2fPackingSlip%2fPackingSlipwShipApp";
            // Use original nameVal for URL parameters
            const qs = `?${path}&rs:Command=Render&rc:Parameters=true&DC=1` + jobParams + `&OrderNum=${encodeURIComponent(so)}` + `&MasterID=${encodeURIComponent(masterId)}` + `&PackingListName=${encodeURIComponent(nameVal)}` + `&PS=${encodeURIComponent(gPS)}` + `&ShipDate=${encodeURIComponent(gDate)}`;
            return base + qs;
        }


        function buildSsrsUrlMaster(row) {
            const so = row.SO ?? "";
            if (!so) return null;
            const base = "http://aquaerprep/ReportServer/Pages/ReportViewer.aspx";
            const path = "%2fEpicor10Live%2freports%2fMasterPackingSlip%2fMasterPacking";
            const qs = `?${path}&rs:Command=Render&rc:Parameters=true&DC=1` + `&OrderNum=${encodeURIComponent(so)}`;
            return base + qs;
        }

        // computeRowClass
        function computeRowClass(row, forcedClass = null) {
            if (forcedClass) return forcedClass;
            const nameVal = (row.Name || "").trim();
            const jobClosed = row.JobClosed; // Use boolean directly
            const shipDateStr = (row.ShipDate || "").trim();
            if (jobClosed) return "closed";
            if (nameVal === "Packing List Not Set") return "nopackinglist";
            if (shipDateStr === "ShipDate Not Set" && nameVal !== "Packing List Not Set") return "shipnotset";

            const shipDate = parseLocalDate(shipDateStr); // Use robust parser
            if (shipDate) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                if (shipDate <= today) return "shiptoday";
                else return "shipfuture";
            }
            return "";
        }

        // buildTBody
        function buildTBody(rows, forcedClass = null) {
            const tbody = document.createElement('tbody');
             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/; // Moved regex here

            if (rows.length === 0) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = 10;
                td.textContent = 'No jobs found matching your criteria.';
                td.style.textAlign = 'center';
                td.style.padding = '20px';
                td.style.fontStyle = 'italic';
                tr.appendChild(td);
                tbody.appendChild(tr);
                return tbody;
            }


            for (const row of rows) {
                const rowClass = computeRowClass(row, forcedClass);
                const tr = document.createElement('tr');
                if (rowClass) tr.className = rowClass;

                const tdMaster = document.createElement('td');
                tdMaster.textContent = row.MasterID ?? "";
                tr.appendChild(tdMaster);

                const tdJob = document.createElement('td');
                tdJob.textContent = row.JobNum ?? "";
                tr.appendChild(tdJob);

                const tdSO = document.createElement('td');
                const soVal = row.SO ?? "";
                const masterSsrsUrl = buildSsrsUrlMaster(row);
                if (masterSsrsUrl) {
                    const a = document.createElement('a');
                    a.href = masterSsrsUrl;
                    a.target = "_blank";
                    a.rel = "noopener";
                    a.title = "Open SSRS Master Packing List Report";
                    a.innerHTML = escapeHtml(soVal);
                    tdSO.appendChild(a);
                } else {
                    tdSO.textContent = soVal;
                }
                tr.appendChild(tdSO);

                const tdProjID = document.createElement('td');
                tdProjID.textContent = row.ProjectID ?? "";
                tr.appendChild(tdProjID);

                const tdProj = document.createElement('td');
                tdProj.textContent = row.ProjectName ?? "";
                tr.appendChild(tdProj);

                const tdName = document.createElement('td');
                const nameVal = (row.Name || "").trim();
                let displayName = nameVal; // Default to original name

                // *** Check and strip date suffix from Packing List Name ***
                if (dateSuffixRegex.test(nameVal)) {
                    displayName = nameVal.replace(dateSuffixRegex, '');
                }
                // *** End modification ***

                const ssrsUrl = buildSsrsUrl(row); // Build URL with original name
                if (ssrsUrl) {
                    const a = document.createElement('a');
                    a.href = ssrsUrl;
                    a.target = "_blank";
                    a.rel = "noopener";
                    a.title = "Open SSRS Packing Slip";
                    a.innerHTML = escapeHtml(displayName); // Use potentially modified name for display
                    tdName.appendChild(a);
                } else {
                    tdName.textContent = displayName; // Use potentially modified name for display
                }
                tr.appendChild(tdName);

                const tdReqShip = document.createElement('td');
                // *** Req Ship Date formatting - Only apply date format if it doesn't have the " - {Date}" structure ***
                const reqDateVal = row.ReqDate;
                if (typeof reqDateVal === 'string' && dateSuffixRegex.test(reqDateVal)) {
                     tdReqShip.textContent = reqDateVal.replace(dateSuffixRegex, ''); // Strip date if present
                } else {
                     tdReqShip.textContent = formatShortDate(reqDateVal); // Format as date otherwise
                }
                // *** End modification ***
                tr.appendChild(tdReqShip);

                const tdUrgency = document.createElement('td');
                // const urgency = getUrgency(row.ReqDate, row.ShipDate, row.JobClosed); // <-- No longer needed
                tdUrgency.textContent = row.urgencyText; // Use pre-calculated value
                tdUrgency.className = row.urgencyClass; // Use pre-calculated value
                tr.appendChild(tdUrgency); // Use boolean JobClosed

                const tdShip = document.createElement('td');
                if (row.JobClosed) { // Use boolean directly
                    tdShip.textContent = formatShortDate(row.ClosedShipDate) ?? ''; // Use ClosedShipDate if job is closed
                } else {
                    tdShip.textContent = formatShortDate(row.ShipDate) ?? ''; // Otherwise, use ShipDate
                }
                tr.appendChild(tdShip);

                const tdUser = document.createElement('td');
                tdUser.textContent = row.UserCreated ?? "";
                tr.appendChild(tdUser);

                tbody.appendChild(tr);
            }
            return tbody;
        }


        // Function to repaint critical status based on map
        function paintCriticalOnLiveTable(sessionId) {
            if (!isCurrentSession(sessionId)) return;
            const table = document.getElementById('mastersTable');
            if (!table || !table.tBodies[0]) return;

            const trs = Array.from(table.tBodies[0].querySelectorAll('tr'));
             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/; // Define regex

            trs.forEach(tr => {
                if (tr.children.length < 6) return; // Skip if not a data row

                let job = tr.children[1]?.textContent.trim();
                
                 // Get potentially modified name from cell (link or text)
                 let displayedName = tr.children[5]?.textContent.trim() || "";
                 const link = tr.children[5]?.querySelector('a');
                 if(link) displayedName = link.textContent.trim();

                // Find original name from rawMasters data based on job and potentially displayedName
                // This is less efficient but necessary if stripping happens before this runs
                 let originalName = "";
                 const matchingRawRow = rawMasters.find(r => r.JobNum === job && (r.Name || "").replace(dateSuffixRegex, '') === displayedName);
                 if (matchingRawRow) {
                     originalName = matchingRawRow.Name || "";
                 } else {
                     // Fallback if no exact match (less likely but possible)
                     originalName = displayedName;
                 }


                // Use job number (primary key) to check critical status
                const status = criticalByJob.get(job);
                if (status === "Invalid") {
                    tr.classList.add("critical");
                } else {
                    tr.classList.remove("critical"); // Explicitly remove if not critical
                }
            });
        }

        function swapTBody(newTBody, sessionId) {
            if (!isCurrentSession(sessionId)) return;
            const table = document.getElementById('mastersTable');
            if (!table) return;
            const oldTBody = table.tBodies[0] || document.createElement('tbody');
            if (!table.tBodies[0]) table.appendChild(oldTBody);
            table.replaceChild(newTBody, oldTBody);
        }

        function updateResultsCount(rows, query = null, filter = null) {
            const el = document.getElementById('tableResultsCount');
            if (!el) return;
            const total = rawMasters.length; // Use rawMasters length for total
            const count = rows.length;
            if (query) {
                el.textContent = `Found ${count} job${count !== 1 ? 's' : ''} matching "${query}"`;
                el.style.display = 'block';
            } else if (filter) {
                const pretty = {
                    closed: 'Closed',
                    nopackinglist: 'No List',
                    critical: 'Critical',
                    setshipdate: 'Set Date',
                    shipdateset: 'Date Set',
                    shipfuture: 'Future'
                } [filter] || 'Filter';
                el.textContent = `Showing ${count} job${count !== 1 ? 's' : ''} for "${pretty}"`;
                el.style.display = 'block';
            } else if (count === total && total > 0) {
                 el.textContent = `Showing all ${total} jobs`;
                 el.style.display = 'block';
            } else if (count > 0 && count < total) {
                 el.textContent = `Showing ${count} of ${total} jobs`; // Show count out of total
                 el.style.display = 'block';
            } else if (count === 0 && (query || filter)) {
                 el.textContent = 'No jobs found matching your criteria.';
                 el.style.display = 'block';
            } else {
                el.style.display = 'none';
            }
        }


        // Render table, apply critical status after
        async function renderTable(rows, forcedClass = null, {
            withCritical = true,
            sessionId
        } = {}) {
            const displayRows = rows; // Sorter is now applied *before* calling this
            const tempBody = buildTBody(displayRows, forcedClass); // Build tbody

            swapTBody(tempBody, sessionId); // Swap it into the DOM

            // Apply critical AFTER tbody is live, only if needed and data exists
            if (withCritical && displayRows && displayRows.length > 0) {
                paintCriticalOnLiveTable(sessionId);
            }
        }

        // Kiosk Table Render
        function renderKioskTable(sessionId) {
            if (!isCurrentSession(sessionId)) return;
            const table = document.getElementById('kioskTable');
            if (!table) return;
            const tbody = table.tBodies[0] || table.appendChild(document.createElement('tbody'));
            // Kiosk always shows all masters, respect current sort state
            const allJobsSorted = applySorters(masters, 'masters');
            const newTBody = document.createElement('tbody');

            // Regex to match " - {Date}" at the end of a string
            const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/;

            if (allJobsSorted.length === 0) {
                newTBody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding: 20px; font-style: italic;">No jobs loaded.</td></tr>`;
            } else {
                for (const row of allJobsSorted) {
                    const tr = document.createElement('tr');
                    tr.className = computeRowClass(row);
                    let nameCellHtml;
                    const nameVal = (row.Name || "").trim();
                    let displayName = nameVal;

                    // *** Check and strip date suffix from Packing List Name ***
                    if (dateSuffixRegex.test(nameVal)) {
                        displayName = nameVal.replace(dateSuffixRegex, '');
                    }
                    // *** End modification ***

                    const ssrsUrl = buildSsrsUrl(row); // Build URL with original name
                    if (ssrsUrl) {
                         // Use potentially modified name in link text
                        nameCellHtml = `<a href="${ssrsUrl}" target="_blank" rel="noopener" title="Open SSRS Packing Slip">${escapeHtml(displayName)}</a>`;
                    } else {
                        // Use potentially modified name directly
                        nameCellHtml = escapeHtml(displayName);
                    }

                    const soVal = row.SO ?? "";
                    const masterSsrsUrl = buildSsrsUrlMaster(row);
                    let soCellHtml;
                    if (masterSsrsUrl) {
                        soCellHtml = `<a href="${masterSsrsUrl}" target="_blank" rel="noopener" title="Open SSRS Master Packing List Report">${escapeHtml(soVal)}</a>`;
                    } else {
                        soCellHtml = escapeHtml(soVal);
                    }

                    // Get urgency data
                    // const urgency = getUrgency(row.ReqDate, row.ShipDate, row.JobClosed); // <-- No longer needed
                     // Format ShipDate for display
                     const displayShipDate = row.JobClosed ? formatShortDate(row.ClosedShipDate) : formatShortDate(row.ShipDate);

                    tr.innerHTML = `<td>${escapeHtml(row.JobNum)}</td>
                                    <td>${soCellHtml}</td>
                                    <td>${escapeHtml(row.ProjectID)}</td>
                                    <td>${nameCellHtml}</td> 
                                    <td>${escapeHtml(displayShipDate)}</td>
                                    <td class="${row.urgencyClass}">${row.urgencyText}</td>`; // <-- Use pre-calculated values
                    newTBody.appendChild(tr);
                }
            }
            table.replaceChild(newTBody, tbody);
        }

        // Paint critical status on Kiosk Table
        function paintCriticalOnKioskTable(sessionId) {
            if (!isCurrentSession(sessionId)) return;
            const table = document.getElementById('kioskTable');
            if (!table || !table.tBodies[0]) return;

            const trs = Array.from(table.tBodies[0].querySelectorAll('tr'));
             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/; // Define regex

            trs.forEach(tr => {
                if (tr.children.length < 6) return;

                let job = tr.children[0]?.textContent.trim();
                 // Get potentially modified name from cell (link or text)
                 let displayedName = tr.children[3]?.textContent.trim() || "";
                 const link = tr.children[3]?.querySelector('a');
                 if(link) displayedName = link.textContent.trim();

                // Use job number (primary key) to check critical status
                const status = criticalByJob.get(job);
                if (status === "Invalid") {
                    tr.classList.add("critical");
                } else {
                    tr.classList.remove("critical");
                }
            });
        }

        // Refresh machinery
        async function refreshDataOnce({
            silent = false
        } = {}) {
            if (isRefreshing) return;
            isRefreshing = true;
            setRefreshing(true);
            if (silent) {
                showToast('Auto-refreshing data‚Ä¶', {
                    type: 'info',
                    duration: 1200
                });
            } else {
                showToast('Refreshing data‚Ä¶', {
                    type: 'info'
                });
            }
            const {
                id: sessionId,
                signal
            } = beginSession();
            try {
                const [mastersRes, missingRes] = await Promise.all([fetch("/api/allmasters", {
                    cache: "no-store",
                    signal
                }), fetch("/api/missingjobs", {
                    cache: "no-store",
                    signal
                })]);
                const mastersJson = await mastersRes.json();
                const missingJson = await missingRes.json();
                if (!isCurrentSession(sessionId)) return;
                if (mastersJson.error) throw new Error(mastersJson.message || "allmasters error");
                if (missingJson.error) throw new Error(missingJson.message || "missingjobs error");
                let newMastersRaw = mastersJson.data || [];
                const newMissing = missingJson.data || [];
                const mastersChanged = computeMastersSignature(newMastersRaw) !== prevMastersSig;
                const missingChanged = computeMissingSignature(newMissing) !== prevMissingSig;
                if (mastersChanged) {
                    rawMasters = newMastersRaw; // Update raw masters as well
                    
                    // *** NEW: Add urgency sort key ***
                    rawMasters.forEach(row => {
                        const urgency = getUrgency(row.ReqDate, row.ShipDate, row.JobClosed);
                        row.urgencySortKey = urgency.sortKey;
                        row.urgencyText = urgency.text; 
                        row.urgencyClass = urgency.class;
                    });
                    // *** END NEW ***
                    
                    masters = sortMastersDefault(rawMasters); // Apply default sort immediately
                    prevMastersSig = computeMastersSignature(newMastersRaw); // Use raw for signature
                    updateLegendCounts(); // Update counts based on new raw data
                    await calculateTotalCriticalCount(signal); // Recalculate critical
                    if (!isCurrentSession(sessionId)) return;
                }
                if (missingChanged) {
                    missingJobs = newMissing;
                    
                    // *** NEW: Add urgency sort key to missing jobs ***
                    missingJobs.forEach(row => {
                        const urgency = getUrgencySimple(row.ReqShipDate);
                        row.urgencySortKey = urgency.sortKey;
                        row.urgencyText = urgency.text;
                        row.urgencyClass = urgency.class;
                    });
                    // *** END NEW ***

                    prevMissingSig = computeMissingSignature(newMissing);
                    const mc = missingJson.count ?? newMissing.length;
                    document.getElementById("countMissing").textContent = mc;
                }

                // Only re-render if data actually changed
                if (mastersChanged || missingChanged) {
                    renderStatsChart();
                    const q = searchInput.value.trim().toLowerCase();
                    let view; // This will hold the data to be displayed in mastersTable

                    // Determine the current view based on filter or search
                    if (q) { // Search active
                        view = masters.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(q)));
                    } else if (activeFilter) { // Filter active
                        const filter = activeFilter;
                        view = masters.filter(row => { // Filter the globally sorted masters
                            const nameVal = (row.Name || "").trim();
                            const jobClosed = row.JobClosed;
                            const shipDateStr = (row.ShipDate || "").trim();
                            // Filter logic... (same as before)
                             switch (filter) {
                                case "closed": return jobClosed;
                                case "nopackinglist": return nameVal === "Packing List Not Set";
                                case "critical": return (criticalByJob.get(row.JobNum) === "Invalid");
                                case "setshipdate": return shipDateStr === "ShipDate Not Set" && nameVal != "Packing List Not Set";
                                case "shipdateset": {
                                    const shipDate = parseLocalDate(shipDateStr);
                                    const today = new Date(); today.setHours(0, 0, 0, 0);
                                    return shipDate && shipDate <= today;
                                }
                                case "shipfuture": {
                                    const shipDate = parseLocalDate(shipDateStr);
                                    const today = new Date(); today.setHours(0, 0, 0, 0);
                                    return shipDate && shipDate > today;
                                }
                                default: return false;
                            }
                        });
                    } else { // No filter or search
                        view = masters; // Use the globally sorted masters
                    }
                    
                    // Apply the current sort state (default or user-selected) to the view
                    const sortedView = applySorters(view, 'masters'); 
                    
                    // Render the main table with the sorted view
                    await renderTable(sortedView, null, { // forcedClass is null as row colors depend on data
                        withCritical: true,
                        sessionId
                    });
                    if (!isCurrentSession(sessionId)) return;
                    updateResultsCount(sortedView, q, activeFilter); // Update count based on rendered data

                    // Render Kiosk Table (always uses full 'masters' data, respects sort state)
                    renderKioskTable(sessionId); 
                    paintCriticalOnKioskTable(sessionId); 

                    // Animate rows if masters data changed
                    const displayedViewKeys = new Set(sortedView.map(r => `${r.JobNum}|${r.Name || ""}`));
                    if (mastersChanged) animateRows(displayedViewKeys);
                    lastViewKeys = displayedViewKeys;

                    // Handle missing jobs table visibility and content based on search/pin state
                    const qNow = searchInput.value.trim().toLowerCase();
                    let missingToShow = [];
                    if (searchControlsMissing && qNow) { // Search controls missing table visibility
                        missingToShow = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(qNow)));
                         missingVisible = true; // Show if search has results or not
                         document.getElementById("missingCard").classList.add("active"); // Keep active during search
                    } else if (missingPinned) { // Missing table is pinned
                        missingToShow = missingJobs;
                         missingVisible = true;
                         document.getElementById("missingCard").classList.add("active");
                    } else { // Neither search nor pinned
                        missingVisible = false;
                        document.getElementById("missingCard").classList.remove("active");
                    }
                    
                    // Render missing jobs table with appropriate data and sort state
                     renderMissingJobs(applySorters(missingToShow, 'missing'));
                     updateMissingJobsResultsCount(missingToShow, searchControlsMissing ? qNow : null);


                    showToast('Data updated.', {
                        type: 'success',
                        duration: 1400
                    });
                } else { // No data changed
                    showToast('No changes detected.', {
                        type: 'info',
                        duration: 1200,
                        silent: silent
                    });
                     // Still need to potentially update missing table if search term exists but data didn't change overall
                     const q = searchInput.value.trim().toLowerCase();
                     if (searchControlsMissing && q) {
                         const matchedMissing = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(q)));
                         renderMissingJobs(applySorters(matchedMissing, 'missing'));
                         updateMissingJobsResultsCount(matchedMissing, q);
                     } else if (!missingPinned) { // Ensure missing table is hidden if not pinned and no search
                          renderMissingJobs([]);
                          updateMissingJobsResultsCount([]);
                     }
                }
                nextRefreshAt = Date.now() + refreshIntervalMs;
                updateCountdown();
            } catch (e) {
                if (e.name !== 'AbortError') {
                    document.getElementById("error").textContent = "‚ö†Ô∏è Refresh failed: " + e.message;
                    showToast(`Refresh failed: ${e.message}`, {
                        type: 'error',
                        duration: 3200
                    });
                }
            } finally {
                isRefreshing = false;
                setRefreshing(false);
                searchWrap?.classList.remove('searching');
            }
        }

        // Auto-update functions
        function startAutoUpdate(ms = refreshIntervalMs) {
            if (autoTimer) clearInterval(autoTimer);
            prevMastersSig = computeMastersSignature(rawMasters); // Use rawMasters for signature
            prevMissingSig = computeMissingSignature(missingJobs);
            nextRefreshAt = Date.now() + ms;
            startCountdown();
            autoTimer = setInterval(async () => {
                await refreshDataOnce({
                    silent: true
                });
                // nextRefreshAt = Date.now() + refreshIntervalMs; // Handled within refreshDataOnce
                // updateCountdown(); // Handled within refreshDataOnce
            }, ms);
        }

        function stopAutoUpdate() {
            if (autoTimer) {
                clearInterval(autoTimer);
                autoTimer = null;
            }
        }
        async function handleRefresh() {
            if (isRefreshing) return;
            await refreshDataOnce({
                silent: false
            });
        }
        async function handleRestart() {
            if (isRefreshing) return;
            setRefreshing(true);
            try {
                stopAutoUpdate();
                if (countdownTimer) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
                nextRefreshAt = 0;
                updateCountdown();
                beginSession(); // Abort any ongoing fetches
                 // Reset sort states to default
                 mastersSortState = { ...defaultMastersSort };
                 missingSortState = { ...defaultMissingSort };
                 updateSortUI('mastersTable', mastersSortState);
                 updateSortUI('missingJobsTable', missingSortState);
                 document.getElementById('resetSortMasters').style.display = 'none'; // Hide reset links
                 document.getElementById('resetSortMissing').style.display = 'none';

                 // Clear search and filter states
                 searchInput.value = '';
                 searchWrap.classList.remove('has-value');
                 activeFilter = null;
                 document.querySelectorAll("#legend .chip").forEach(c => c.classList.remove("active"));
                 missingPinned = false; // Unpin missing table
                 searchControlsMissing = false;
                 missingVisible = false;

                showToast('Restarting dashboard‚Ä¶', {
                    type: 'info'
                });
                await loadDashboard(); // Reload all data
            } catch (e) {
                document.getElementById("error").textContent = "‚ö†Ô∏è " + e.message;
                showToast(`Dashboard load failed: ${e.message}`, {
                    type: 'error',
                    duration: 3600
                });
            } finally {
                setRefreshing(false); // Ensure loader/refresh indicators are hidden
            }
        }
        document.getElementById('refreshBtn').addEventListener('click', handleRefresh);
        document.getElementById('restartBtn').addEventListener('click', handleRestart);

        // Load & bootstrap
        let rawMasters = []; // Use let if it might be reassigned (it is in refresh)
        async function loadDashboard() {
            showLoader();
            setLegendDisabled(true);
            searchWrap?.classList.add('searching');
            showToast('Loading dashboard‚Ä¶', {
                type: 'info',
                duration: 1800
            });
            stopAutoUpdate();
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            nextRefreshAt = 0;
            updateCountdown();
            const {
                id: sessionId,
                signal
            } = beginSession();
            try {
                const mastersRes = await fetch("/api/allmasters", {
                    signal
                });
                const mastersJson = await mastersRes.json();
                if (!isCurrentSession(sessionId)) return;
                if (mastersJson.error) throw new Error(mastersJson.message);
                rawMasters = mastersJson.data || []; // Store raw data
                
                // *** NEW: Add urgency sort key ***
                rawMasters.forEach(row => {
                    const urgency = getUrgency(row.ReqDate, row.ShipDate, row.JobClosed);
                    row.urgencySortKey = urgency.sortKey;
                    row.urgencyText = urgency.text; 
                    row.urgencyClass = urgency.class;
                });
                // *** END NEW ***

                masters = sortMastersDefault(rawMasters); // Apply default sort
                const missRes = await fetch("/api/missingjobs", {
                    signal
                });
                const missJson = await missRes.json();
                if (!isCurrentSession(sessionId)) return;
                if (missJson.error) throw new Error(missJson.message);
                missingJobs = missJson.data || [];
                
                // *** NEW: Add urgency sort key to missing jobs ***
                missingJobs.forEach(row => {
                    const urgency = getUrgencySimple(row.ReqShipDate);
                    row.urgencySortKey = urgency.sortKey;
                    row.urgencyText = urgency.text;
                    row.urgencyClass = urgency.class;
                });
                // *** END NEW ***
                
                document.getElementById("countMissing").textContent = missJson.count ?? 0;
                updateLegendCounts();
                const initialView = applySorters(masters, 'masters'); // Apply current (default) sort
                await calculateTotalCriticalCount(signal);
                if (!isCurrentSession(sessionId)) return;
                renderStatsChart(); /* Render chart */
                await renderTable(initialView, null, {
                    withCritical: true,
                    sessionId
                });
                if (!isCurrentSession(sessionId)) return;
                updateResultsCount(initialView);
                 // Render Kiosk Table initially
                 renderKioskTable(sessionId);
                 paintCriticalOnKioskTable(sessionId);
                animateRows(new Set(initialView.map(r => `${r.JobNum}|${r.Name || ""}`)));

                // Hide missing table section initially
                 document.getElementById('missingJobsTitle').style.display = 'none';
                 document.getElementById('missingJobsTableWrapper').style.display = 'none';
                 document.getElementById('missingJobsResultsCount').style.display = 'none';
                 document.getElementById('resetSortMasters').style.display = 'none'; // Ensure reset links hidden
                 document.getElementById('resetSortMissing').style.display = 'none';


                if (!listenersReady) {
                    setupLegendClicks();
                    setupSearchInput();
                    setupSortableTables(); // Add sort listeners
                    setupResetLinks(); // ADDED: Set up reset link listeners
                    listenersReady = true;
                }
                 updateSortUI('mastersTable', mastersSortState); // Ensure UI matches default state
                 updateSortUI('missingJobsTable', missingSortState); // Ensure UI matches default state

                startAutoUpdate(refreshIntervalMs);
                showToast('Dashboard ready.', {
                    type: 'success',
                    duration: 1600
                });
            } catch (err) {
                if (err.name !== 'AbortError') {
                    document.getElementById("error").textContent = "‚ö†Ô∏è " + err.message;
                    console.error("Dashboard load failed:", err);
                    showToast(`Dashboard load failed: ${err.message}`, {
                        type: 'error',
                        duration: 3600
                    });
                }
            } finally {
                if (isCurrentSession(sessionId)) {
                    hideLoader();
                    setLegendDisabled(false);
                    searchWrap?.classList.remove('searching');
                }
            }
        }


        // Critical totals (fetch ALL critical statuses)
        async function calculateTotalCriticalCount(signal) {
            try {
                const dataForCritical = rawMasters; // Use rawMasters here
                const uniqueJobs = [...new Set(dataForCritical.map(r => r.JobNum).filter(Boolean))];
                const firstNameForJob = new Map();
                for (const row of dataForCritical)
                    if (row.JobNum && !firstNameForJob.has(row.JobNum)) firstNameForJob.set(row.JobNum, row.Name || "");
                const results = await Promise.all(uniqueJobs.map(async job => {
                    const name = firstNameForJob.get(job) || "";
                    const url = `/api/critical?jobNum=${encodeURIComponent(job)}&jobName=${encodeURIComponent(name)}`;
                    const res = await fetch(url, {
                        signal
                    });
                    if (!res.ok) return {
                        job,
                        status: "Valid"
                    };
                    const json = await res.json();
                    const item = json.data?.[0];
                    return {
                        job,
                        status: item ? item.Critical : "Valid"
                    };
                }));
                criticalByJob.clear();
                for (const r of results) criticalByJob.set(r.job, r.status);
                totalCriticalCount = results.filter(r => r.status === "Invalid").length;
                document.getElementById("countCritical").textContent = totalCriticalCount;
                setPct("pctCritical", totalCriticalCount, dataForCritical.length || 0); // Use raw length for pct base
            } catch (err) {
                if (err.name !== 'AbortError') console.warn("Failed to calculate total critical count:", err);
            }
        }


        // Legend counts & percentages
        function updateLegendCounts() {
            let countClosed = 0,
                countNoPackingList = 0,
                countSetShipDate = 0,
                countShipDateSet = 0,
                countShipFuture = 0;
            // Counts should be based on the total dataset (rawMasters)
            rawMasters.forEach(row => {
                const nameVal = (row.Name || "").trim();
                const jobClosed = row.JobClosed; /* Boolean */
                const shipDateStr = (row.ShipDate || "").trim();
                if (jobClosed) countClosed++;
                // Count "No List" only if not closed
                if (!jobClosed && nameVal === "Packing List Not Set") countNoPackingList++;
                 // Count "Set Date" only if not closed and not "No List"
                if (!jobClosed && nameVal !== "Packing List Not Set" && shipDateStr === "ShipDate Not Set") countSetShipDate++;


                // Count date-related categories only if not closed and ship date exists
                if (!jobClosed && shipDateStr && shipDateStr !== "ShipDate Not Set") {
                    const shipDate = parseLocalDate(shipDateStr); // Use robust parser
                     if (shipDate) {
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        if (shipDate <= today) countShipDateSet++;
                        else countShipFuture++;
                    }
                }
            });
            document.getElementById("countClosed").textContent = countClosed;
            document.getElementById("countNoPackingList").textContent = countNoPackingList;
            document.getElementById("countSetShipDate").textContent = countSetShipDate;
            document.getElementById("countShipDateSet").textContent = countShipDateSet;
            document.getElementById("countShipFuture").textContent = countShipFuture;
            // Critical count is updated separately after fetch
            // document.getElementById("countCritical").textContent = totalCriticalCount;

            const total = rawMasters.length || 0; // Use raw total for percentages
            setPct("pctClosed", countClosed, total);
            setPct("pctNoPackingList", countNoPackingList, total);
            // Critical percentage updated in calculateTotalCriticalCount
            setPct("pctSetShipDate", countSetShipDate, total);
            setPct("pctShipDateSet", countShipDateSet, total);
            setPct("pctShipFuture", countShipFuture, total);
            document.getElementById("totalJobsCount").textContent = `(${total})`; // Show raw total
        }


        // Missing jobs render
        function renderMissingJobs(rows) {
            const title = document.getElementById("missingJobsTitle");
            const wrapper = document.getElementById("missingJobsTableWrapper");
            const table = document.getElementById("missingJobsTable");
            const tbody = table.querySelector("tbody");
            const resetLink = document.getElementById('resetSortMissing');

            if (!missingVisible) {
                title.style.display = "none";
                wrapper.style.display = "none";
                 if (resetLink) resetLink.style.display = 'none'; // Hide reset link too
                if (tbody) tbody.innerHTML = "";
                return;
            }
            title.style.display = ""; // Uses flex display from CSS
            wrapper.style.display = "block";
            if (!tbody) return;
            tbody.innerHTML = "";
            
            // Check if current sort is default BEFORE sorting rows for rendering
            const isDefaultMissingSort = missingSortState.column === defaultMissingSort.column && missingSortState.direction === defaultMissingSort.direction;
             if (resetLink) resetLink.style.display = isDefaultMissingSort ? 'none' : 'inline-block';

            const sortedRows = applySorters(rows, 'missing'); // Apply current sort
            
            if (sortedRows.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="6" style="text-align:center; padding: 15px; font-style: italic;">No missing jobs found matching criteria.</td></tr>`;
                return;
            }

            // Regex to potentially strip date from ReqShipDate if needed, similar to masters table
             const dateSuffixRegex = / - (\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/;

            for (const r of sortedRows) {
                const tr = document.createElement('tr');
                const soVal = r.SO ?? "";
                const masterUrl = buildSsrsUrlMaster(r); // Re-use master link logic if SO exists
                let soCellHtml = escapeHtml(soVal);
                if (masterUrl) {
                    soCellHtml = `<a href="${masterUrl}" target="_blank" rel="noopener" title="Open SSRS Master Packing List Report">${escapeHtml(soVal)}</a>`;
                }

                // Format ReqShipDate - strip if needed, otherwise format
                let reqShipDisplay = "";
                const reqDateVal = r.ReqShipDate;
                 if (typeof reqDateVal === 'string' && dateSuffixRegex.test(reqDateVal)) {
                     reqShipDisplay = reqDateVal.replace(dateSuffixRegex, ''); // Strip date if present
                 } else {
                     reqShipDisplay = formatShortDate(reqDateVal); // Format as date otherwise
                 }

                // const urgency = getUrgencySimple(r.ReqShipDate); // <-- No longer needed
                tr.innerHTML = `<td>${escapeHtml(r.JobNum ?? "")}</td><td>${soCellHtml}</td><td>${escapeHtml(r.ProjectID ?? "")}</td><td>${escapeHtml(r.ProjectName ?? "")}</td><td>${reqShipDisplay}</td><td class="${r.urgencyClass}">${r.urgencyText}</td>`; // <-- Use pre-calculated
                tbody.appendChild(tr);
            }
        }

        // Update missing jobs count
        function updateMissingJobsResultsCount(rows, query = null) {
            const el = document.getElementById('missingJobsResultsCount');
            if (!el) return;
            if (!missingVisible) {
                el.textContent = '';
                el.style.display = 'none';
                return;
            }
            const count = rows.length;
            if (query) {
                el.textContent = `Found ${count} missing job${count !== 1 ? 's' : ''} matching "${query}"`;
            } else {
                 el.textContent = `Showing ${count} job${count !== 1 ? 's' : ''} not in MasterList`;
            }
            // Message for no results is handled inside renderMissingJobs now
            el.style.display = 'block';
        }

        // Legend & Search interactions
        function setupLegendClicks() {
            const cards = document.querySelectorAll("#legend .chip[data-filter], #missingCard");
            cards.forEach(card => {
                card.addEventListener("click", async () => {
                    if (document.body.classList.contains('view-kiosk')) {
                        const viewSelect = document.getElementById('viewSelect');
                        if (viewSelect) {
                            viewSelect.value = 'default';
                            viewSelect.dispatchEvent(new Event('change'));
                            showToast('Exited Kiosk Mode to apply filter.', {
                                type: 'info',
                                duration: 2000
                            });
                        } else {
                            return;
                        }
                    }
                    const {
                        id: sessionId
                    } = beginSession();
                    setLegendDisabled(true);
                    [refreshBtn, restartBtn].forEach(b => b.setAttribute('disabled', 'disabled'));
                    searchWrap?.classList.add('searching');
                    try {
                        const filter = card.dataset.filter;
                        if (card.id === "missingCard") { // Handle Missing Card toggle
                             missingPinned = !missingPinned; // Toggle pinned state
                             searchControlsMissing = false; // Pin overrides search control
                             missingVisible = missingPinned; // Visibility matches pinned state
                             const currentQuery = searchInput.value.trim().toLowerCase();

                            if (missingVisible) {
                                card.classList.add("active");
                                let rowsToShow = missingJobs;
                                // If search is active WHILE pinning, show filtered missing jobs
                                if (currentQuery) {
                                    rowsToShow = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(currentQuery)));
                                    renderMissingJobs(applySorters(rowsToShow, 'missing')); // Apply sort
                                    updateMissingJobsResultsCount(rowsToShow, currentQuery);
                                } else {
                                     renderMissingJobs(applySorters(missingJobs, 'missing')); // Apply sort
                                     updateMissingJobsResultsCount(missingJobs);
                                }
                                showToast('Showing jobs not yet in the Master List. Click again to hide.', { type: 'info', duration: 2500 });
                                setTimeout(() => document.getElementById('missingJobsSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' }), 100);
                            } else { // Unpinning
                                card.classList.remove("active");
                                // If search is active, keep showing filtered results even if unpinned
                                if (currentQuery) {
                                     const matchedMissing = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(currentQuery)));
                                     searchControlsMissing = true; // Let search control visibility now
                                     missingVisible = true; // Keep visible due to search
                                     renderMissingJobs(applySorters(matchedMissing, 'missing'));
                                     updateMissingJobsResultsCount(matchedMissing, currentQuery);
                                     showToast('Hidden pinned "Not In MasterList", still showing search results.', { type: 'info', duration: 2200 });

                                } else { // No search, truly hide
                                    missingVisible = false;
                                    searchControlsMissing = false;
                                    renderMissingJobs([]);
                                    updateMissingJobsResultsCount([]);
                                    showToast('Hidden "Not In MasterList".', { type: 'info', duration: 1800 });
                                }
                            }
                        } else { // Handle regular filter cards
                            if (activeFilter === filter) { // Deactivate filter
                                activeFilter = null;
                                card.classList.remove("active");
                                const sortedView = applySorters(masters, 'masters'); // Apply current sort to all masters
                                await renderTable(sortedView, null, { withCritical: true, sessionId });
                                updateResultsCount(masters); // Show count for all
                                showToast('Filter cleared. Showing all jobs.', { type: 'success', duration: 1800 });
                            } else { // Activate new filter
                                activeFilter = filter;
                                document.querySelectorAll("#legend .chip").forEach(c => c.classList.remove("active"));
                                card.classList.add("active");

                                // Clear search bar when applying a filter
                                if (searchInput.value) {
                                    searchInput.value = '';
                                    searchWrap.classList.remove('has-value');
                                    // Also hide missing table if it was shown by search
                                     if (searchControlsMissing && !missingPinned) {
                                         missingVisible = false;
                                         searchControlsMissing = false;
                                         renderMissingJobs([]);
                                         updateMissingJobsResultsCount([]);
                                         document.getElementById("missingCard").classList.remove("active");

                                     }
                                }


                                const pretty = card.querySelector('.label')?.textContent || 'Filter';
                                sleep(100).then(() => showToast(`Applying filter: ${pretty}‚Ä¶`, { type: 'info', duration: 1800 }));

                                const filtered = masters.filter(row => { // Filter the globally sorted masters
                                    const nameVal = (row.Name || "").trim();
                                    const jobClosed = row.JobClosed;
                                    const shipDateStr = (row.ShipDate || "").trim();
                                    // Filter logic... (same as before)
                                      switch (filter) {
                                        case "closed": return jobClosed;
                                        case "nopackinglist": return !jobClosed && nameVal === "Packing List Not Set"; // Ensure not closed
                                        case "critical": return (criticalByJob.get(row.JobNum) === "Invalid");
                                        case "setshipdate": return !jobClosed && nameVal !== "Packing List Not Set" && shipDateStr === "ShipDate Not Set"; // Ensure not closed, not 'no list'
                                        case "shipdateset": {
                                             if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false; // Ensure not closed, has date
                                             const shipDate = parseLocalDate(shipDateStr);
                                             const today = new Date(); today.setHours(0, 0, 0, 0);
                                             return shipDate && shipDate <= today;
                                         }
                                         case "shipfuture": {
                                             if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false; // Ensure not closed, has date
                                             const shipDate = parseLocalDate(shipDateStr);
              
                                             const today = new Date(); today.setHours(0, 0, 0, 0);
                                             return shipDate && shipDate > today;
                                         }
                                         default: return false;
                                     }
                                });
                                
                                const sortedView = applySorters(filtered, 'masters'); // Apply current sort to filtered data
                                
                                await renderTable(sortedView, null, { withCritical: true, sessionId }); // forcedClass is null
                                updateResultsCount(sortedView, null, filter);
                                sleep(3000).then(() => showToast(`Showing ${sortedView.length} job${sortedView.length !== 1 ? 's': ''} for: ${pretty}`, { type: 'success', duration: 1800 }));
								sleep(6000).then(() => showToast(`Click [${pretty}] button to restore default sort!`, { type: 'success', duration: 1800 }));
                            }
                        }
                    } finally {
                        searchWrap?.classList.remove('searching');
                        if (isCurrentSession(sessionId)) {
                            setLegendDisabled(false);
                            [refreshBtn, restartBtn].forEach(b => b.removeAttribute('disabled'));
                        }
                    }
                });
            });
        }
        
        /**
         * Adds click listeners to all sortable table headers
         */
        function setupSortableTables() {
            document.querySelectorAll('#mastersTable th.sortable, #missingJobsTable th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.column;
                    const table = th.closest('table');
                    const isMasters = table.id === 'mastersTable';
                    
                    let currentState = isMasters ? mastersSortState : missingSortState;
                    const defaultSort = isMasters ? defaultMastersSort : defaultMissingSort;
                    const resetLink = document.getElementById(isMasters ? 'resetSortMasters' : 'resetSortMissing');


                    if (currentState.column === column) {
                        currentState.direction = currentState.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentState.column = column;
                        currentState.direction = 'asc';
                    }

                    if (isMasters) mastersSortState = currentState;
                    else missingSortState = currentState;

                    updateSortUI('mastersTable', mastersSortState);
                    updateSortUI('missingJobsTable', missingSortState);

                     // Show/hide reset link
                     const isDefaultSort = currentState.column === defaultSort.column && currentState.direction === defaultSort.direction;
                     if(resetLink) resetLink.style.display = isDefaultSort ? 'none' : 'inline-block';


                    // Re-run the current render path
                    const q = searchInput.value.trim().toLowerCase();
                    if (!isMasters) { // Sorting the missing table
                         let missingRows = missingJobs;
                         if (q && searchControlsMissing) { // If search is controlling visibility
                             missingRows = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(q)));
                         } else if (!missingPinned && !(q && searchControlsMissing)) { // Hide if not pinned and not search-controlled
                              missingRows = []; // Should not render anything if hidden
                         } // else: missingPinned = true, use all missingJobs

                         renderMissingJobs(applySorters(missingRows, 'missing')); // applySorters handles the new state
                         updateMissingJobsResultsCount(missingRows, (q && searchControlsMissing) ? q : null);
                     } else { // Sorting the masters table
                        // Re-trigger the appropriate render function based on current state (filter or search/all)
                         if (activeFilter) {
                             // Re-apply filter and sort
                             const { id: sessionId } = beginSession(); // Start new session for async render
                             const filtered = masters.filter(row => { // Filter the globally sorted masters
                                const nameVal = (row.Name || "").trim();
                                const jobClosed = row.JobClosed;
                                const shipDateStr = (row.ShipDate || "").trim();
                                // Filter logic... (same as in setupLegendClicks)
                                  switch (activeFilter) {
                                    case "closed": return jobClosed;
                                    case "nopackinglist": return !jobClosed && nameVal === "Packing List Not Set";
                                    case "critical": return (criticalByJob.get(row.JobNum) === "Invalid");
                                    case "setshipdate": return !jobClosed && nameVal !== "Packing List Not Set" && shipDateStr === "ShipDate Not Set";
                                    case "shipdateset": {
                                         if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false;
                                         const shipDate = parseLocalDate(shipDateStr);
                                         const today = new Date(); today.setHours(0, 0, 0, 0);
                                         return shipDate && shipDate <= today;
                                     }
                                     case "shipfuture": {
                                         if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false;
                                         const shipDate = parseLocalDate(shipDateStr);
                                         const today = new Date(); today.setHours(0, 0, 0, 0);
                                         return shipDate && shipDate > today;
                                     }
                                     default: return false;
                                 }
                             });
                             const sortedView = applySorters(filtered, 'masters'); // applySorters uses the updated state
                             renderTable(sortedView, null, { withCritical: true, sessionId });
                             updateResultsCount(sortedView, null, activeFilter); // Update count
                         } else {
                             // Re-trigger search logic (which includes applying sort)
                             searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                         }
                    }
                });
            });
        }

        // ADDED: Setup Reset Links function
        function setupResetLinks() {
            const resetMastersLink = document.getElementById('resetSortMasters');
            const resetMissingLink = document.getElementById('resetSortMissing');

            if (resetMastersLink) {
                resetMastersLink.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent page jump
                    if (mastersSortState.column === defaultMastersSort.column && mastersSortState.direction === defaultMastersSort.direction) {
                        return; // Already default, do nothing
                    }

                    mastersSortState = { ...defaultMastersSort }; // Reset state
                    updateSortUI('mastersTable', mastersSortState); // Update header UI
                    resetMastersLink.style.display = 'none'; // Hide link
                    showToast('Master table sort reset.', { type: 'info', duration: 1500 });


                     // Re-trigger render based on current filter/search state
                     const q = searchInput.value.trim().toLowerCase();
                     if (activeFilter) {
                          // Re-apply filter and sort
                          const { id: sessionId } = beginSession();
                          const filtered = masters.filter(row => { // Filter the globally sorted masters
                            const nameVal = (row.Name || "").trim();
                            const jobClosed = row.JobClosed;
                            const shipDateStr = (row.ShipDate || "").trim();
                             switch (activeFilter) {
                                case "closed": return jobClosed;
                                case "nopackinglist": return !jobClosed && nameVal === "Packing List Not Set";
                                case "critical": return (criticalByJob.get(row.JobNum) === "Invalid");
                                case "setshipdate": return !jobClosed && nameVal !== "Packing List Not Set" && shipDateStr === "ShipDate Not Set";
                                case "shipdateset": {
                                     if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false;
                                     const shipDate = parseLocalDate(shipDateStr);
                                     const today = new Date(); today.setHours(0, 0, 0, 0);
                                     return shipDate && shipDate <= today;
                                 }
                                 case "shipfuture": {
                                     if (jobClosed || !shipDateStr || shipDateStr === "ShipDate Not Set") return false;
                                     const shipDate = parseLocalDate(shipDateStr);
                                     const today = new Date(); today.setHours(0, 0, 0, 0);
                                     return shipDate && shipDate > today;
                                 }
                                 default: return false;
                             }
                          });
                          const sortedView = applySorters(filtered, 'masters'); // Uses reset state now
                          renderTable(sortedView, null, { withCritical: true, sessionId });
                          updateResultsCount(sortedView, null, activeFilter);
                      } else {
                          // Re-trigger search logic (which includes applying sort)
                          searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                      }
                });
            }

            if (resetMissingLink) {
                resetMissingLink.addEventListener('click', (e) => {
                     e.preventDefault();
                     if (missingSortState.column === defaultMissingSort.column && missingSortState.direction === defaultMissingSort.direction) {
                         return; // Already default
                     }

                     missingSortState = { ...defaultMissingSort }; // Reset state
                     updateSortUI('missingJobsTable', missingSortState); // Update UI
                     resetMissingLink.style.display = 'none'; // Hide link
                     showToast('Missing jobs table sort reset.', { type: 'info', duration: 1500 });


                     // Re-render missing table based on current visibility/filter state
                     const q = searchInput.value.trim().toLowerCase();
                     let missingRows = [];
                      if (searchControlsMissing && q) {
                          missingRows = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(q)));
                      } else if (missingPinned) {
                          missingRows = missingJobs;
                      } // else: remains empty if not visible

                      renderMissingJobs(applySorters(missingRows, 'missing')); // applySorters uses reset state
                      updateMissingJobsResultsCount(missingRows, (q && searchControlsMissing) ? q : null);
                });
            }
        }


        function setupSearchInput() {
            clearBtn.addEventListener('click', () => {
                setLegendDisabled(true);
                [refreshBtn, restartBtn].forEach(b => b.setAttribute('disabled', 'disabled'));
                searchWrap.classList.add('searching');
                searchInput.value = '';
                searchWrap.classList.remove('has-value');
                activeFilter = null; // Clear filter on search clear
                document.querySelectorAll("#legend .chip").forEach(c => c.classList.remove("active")); // Deactivate legend

                // Hide missing table unless it's pinned
                 searchControlsMissing = false; // Search no longer controls visibility
                 if (!missingPinned) {
                     missingVisible = false;
                     renderMissingJobs([]);
                     updateMissingJobsResultsCount([]);
                     document.getElementById("missingCard").classList.remove("active");
                 }


                const timerEl = document.getElementById('nextRefreshTimer');
                if (timerEl) timerEl.focus({
                    preventScroll: true
                });
                // Trigger input event to re-render masters table with current sort
                searchInput.dispatchEvent(new Event('input', {
                    bubbles: true
                }));
            });

            searchInput.addEventListener("input", async e => {
                 const q = e.target.value;
                 if (q && q.trim().length) searchWrap.classList.add('has-value');
                 else searchWrap.classList.remove('has-value');
                 searchWrap.classList.add('searching');
                 if (searchDebounce) clearTimeout(searchDebounce);
                 const {
                     id: sessionId
                 } = beginSession();
                 setLegendDisabled(true);
                 [refreshBtn, restartBtn].forEach(b => b.setAttribute('disabled', 'disabled'));
                 searchDebounce = setTimeout(async () => {
                     try {
                         const query = q.trim().toLowerCase();
                         // Clear active filter when typing in search
                         if (activeFilter) {
                              activeFilter = null;
                              document.querySelectorAll("#legend .chip").forEach(c => c.classList.remove("active"));
                         }

                         let view; // Data for masters table
                         let matchedMissing = []; // Data for missing table

                         if (!query) { // No search query
                             view = masters; // Show all masters (respecting current sort)
                             searchControlsMissing = false; // Search doesn't control missing table
                             if (missingPinned) { // Show pinned missing table
                                 missingVisible = true;
                                 matchedMissing = missingJobs;
                                 document.getElementById("missingCard").classList.add("active");
                             } else { // Hide missing table
                                 missingVisible = false;
                                 document.getElementById("missingCard").classList.remove("active");
                             }
                         } else { // Search query exists
                             view = masters.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(query)));
                             matchedMissing = missingJobs.filter(row => Object.values(row).some(v => (v ?? "").toString().toLowerCase().includes(query)));
                             searchControlsMissing = true; // Search now controls missing table visibility
                             missingVisible = true; // Show missing table section
                              document.getElementById("missingCard").classList.add("active"); // Keep card visually active during search
                         }
                         
                         // Apply current sort state to the determined masters view
                         const sortedMastersView = applySorters(view, 'masters'); 
                         await renderTable(sortedMastersView, null, {
                             withCritical: true,
                             sessionId
                         });
                         updateResultsCount(sortedMastersView, query, null); // Update count for masters

                         // Apply current sort state to the determined missing view and render
                          renderMissingJobs(applySorters(matchedMissing, 'missing'));
                          updateMissingJobsResultsCount(matchedMissing, query);


                     } finally {
                         searchWrap.classList.remove('searching');
                         if (isCurrentSession(sessionId)) {
                             setLegendDisabled(false);
                             [refreshBtn, restartBtn].forEach(b => b.removeAttribute('disabled'));
                         }
                     }
                 }, 250);
             });
        }

        // View Mode Toggler
        function setupViewMode() {
            const viewSelect = document.getElementById('viewSelect');
            if (!viewSelect) return;
            const isFirstLoad = !sessionStorage.getItem('dashboardLoaded');
            let targetView = 'default';
            if (isFirstLoad) {
                sessionStorage.setItem('dashboardLoaded', 'true');
                localStorage.setItem('dashboardView', 'default');
            } else {
                targetView = localStorage.getItem('dashboardView') || 'default';
            }
            document.body.className = (targetView === 'default') ? '' : 'view-' + targetView;
            viewSelect.value = targetView;
            viewSelect.addEventListener('change', (e) => {
                const newView = e.target.value;
                localStorage.setItem('dashboardView', newView);
                document.body.className = (newView === 'default') ? '' : 'view-' + newView;
                if (newView === 'kiosk') {
                    showToast('Press the ESC key to exit Kiosk Mode.', {
                        type: 'warn',
                        duration: 4000,
                        center: true
                    });
                }
                setTimeout(() => {
                    if (myStatsChart) myStatsChart.resize();
                }, 50);
            });
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && document.body.classList.contains('view-kiosk')) {
                    const viewSelect = document.getElementById('viewSelect');
                    if (viewSelect) {
                        viewSelect.value = 'default';
                        viewSelect.dispatchEvent(new Event('change'));
                        showToast('Exited Kiosk Mode.', {
                            type: 'info',
                            duration: 1500
                        });
                    }
                }
            });
        }

        // Boot
        setupViewMode();
        loadDashboard();
    </script>
</body>
<!--

### Dashboard Summary (v10.23.25.9.20)

Developer: Chuck Konkol
Last Update: 10/23/2025

This dashboard provides a comprehensive, real-time view of packing list statuses by fetching data from two main API endpoints: `/api/allmasters` and `/api/missingjobs`.

**Core Functionality:**

* **Data Fetching:**
    * Fetches all master jobs and a separate list of "missing" jobs on load.
    * Includes a manual **Refresh** button and a **Restart** button (for a full, clean reload).
    * Automatically refreshes data every 5 minutes (`refreshIntervalMs`).
    * Displays a "Next refresh in..." countdown timer.
    * Uses data signatures (`computeMastersSignature`, `computeMissingSignature`) to check if data has *actually* changed, preventing unnecessary screen updates and showing a "No changes detected" toast.
* **Main Display (Masters Table):**
    * Displays all jobs from the master list in a detailed table.
    * Generates dynamic links to SSRS reports for both the Master Packing List (on SO#) and individual Packing Slips (on PackingList name).
    * Calculates and displays an **Urgency** column with color-coding (e.g., "Overdue", "Due in X days", "TBD") based on required ship dates and actual ship dates.
    * Applies row-level background colors based on job status: `closed` (purple), `nopackinglist` (white), `critical` (red), `shipnotset` (yellow), `shiptoday` (green), and `shipfuture` (blue).
* **Filtering (Legend Chips):**
    * A primary legend of chips shows counts and percentages for all major categories: `Closed`, `No List`, `Critical`, `Set Date`, `Date Set`, and `Future`.
    * These chips act as one-click filters. Clicking a chip filters the main table to show *only* jobs in that category. Clicking it again clears the filter.
    * Applying a filter clears any active search query.
* **Search:**
    * A single search bar allows users to filter data across numerous fields (Job #, SO, ProjectID, etc.).
    * The search filters *both* the main `mastersTable` and the `missingJobsTable` simultaneously.
    * Initiating a search clears any active chip filter.
* **Sorting:**
    * All table headers in both tables are sortable (ascending/descending).
    * The dashboard maintains separate sort states for the main table and the missing jobs table.
    * The main table has a complex *default sort* that groups jobs by status (e.g., jobs with dates set first, then "Set Date", then "No List") before sorting by date.
    * A **"Reset Sort"** link appears next to the table title if any non-default sort is applied.
* **Missing Jobs Display:**
    * A special chip, "Not In MasterList," shows the count of jobs found in production but not yet added to the master packing list.
    * Clicking this chip "pins" the `missingJobsTable` open at the bottom of the page. Clicking it again hides it.
    * This table is *also* shown any time a search is active.
* **Kiosk Mode & Charting:**
    * A "View Mode" dropdown allows switching to **Kiosk Mode**.
    * Kiosk Mode hides the toolbar/search and displays a large-format pie chart (using Chart.js) that visualizes the legend counts.
    * It also shows a simplified table (`kioskTable`) of all jobs, sorted by the currently active sort preference.
    * Clicking a slice on the pie chart will apply that filter and automatically switch the user back to the "Default" view.
* **UX & Feedback:**
    * A full-screen loader appears on initial load.
    * A small "Updating..." badge appears during background refreshes.
    * Non-blocking "toast" notifications provide feedback for all actions (e.g., "Data updated," "Filter cleared," "Refresh failed").

---

### Feature Changelog

**v10.23.25.9.20 (Maintenance Release)**
* **Summary:** Minor internal update.
* **Functionality:**
    * Added version number to the page footer.

**v10.23.25.9.19 (Stability & UX Release)**
* **Summary:** Focused on quality-of-life, stability, and reducing visual noise.
* **Functionality:**
    * Added auto-refresh timer to fetch new data every 5 minutes.
    * Added "Next refresh in..." countdown timer.
    * Implemented data-change detection (`computeMastersSignature`) to prevent screen re-renders if no data has changed.
    * Added "Restart" button for a full, clean reload, separate from "Refresh."
    * Added "Reset Sort" links that appear when a custom sort is active.
    * Added `showToast` notification system for user feedback (e.g., "Data updated," "No changes detected").

**v4.0.0 (Kiosk & Visualization Release)**
* **Summary:** Introduced a high-level "Kiosk Mode" for dashboard displays.
* **Functionality:**
    * Added "View Mode" selector to switch between "Default" and "Kiosk."
    * Implemented `body.view-kiosk` CSS to hide toolbars/search and show new widgets.
    * Added Chart.js pie chart (`statsChart`) to visualize legend counts.
    * Made chart slices clickable to apply filters.
    * Added a simplified `kioskTable` for Kiosk Mode.
    * Added `localStorage` support to remember the user's view mode.

**v3.0.0 (Search & Sort Release)**
* **Summary:** Implemented advanced data interaction features: universal search and column sorting.
* **Functionality:**
    * Added the search bar (`#searchBar`).
    * Search now filters both the main `mastersTable` and the `missingJobsTable`.
    * Made all table headers (`th.sortable`) clickable to sort columns (asc/desc).
    * Created a persistent sort state (`mastersSortState`, `missingSortState`) to remember the user's sort preference.
    * Implemented the complex *default* sort (`sortMastersDefault`) to group jobs by status.
    * Search and Filters now correctly clear each other to prevent conflicts.

**v2.0.0 (Filtering & Urgency Release)**
* **Summary:** Added filtering capabilities and critical business logic.
* **Functionality:**
    * Made the legend chips (`#legend`) clickable to filter the main table.
    * Added the `critical` status, which is fetched from `/api/critical` and applied as a row-level override.
    * Added the "Urgency" column with logic (`getUrgency`) to calculate and display overdue/due statuses.
    * Added the "Not In MasterList" chip and the associated `missingJobsTable` logic.

**v1.0.0 (Initial Dashboard)**
* **Summary:** First functional version. Fetched and displayed all master jobs with basic status colors.
* **Functionality:**
    * Fetches and renders `/api/allmasters` into `mastersTable`.
    * Fetches `/api/missingjobs` data.
    * Calculates and displays counts/percentages in the legend.
    * Applies basic row coloring (`computeRowClass`) for `closed`, `nopackinglist`, `shipnotset`, etc.
    * Generates SSRS links for SO and PackingList.
    * Added initial "Refresh" button.

-->
</html>